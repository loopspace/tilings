% \iffalse meta-comment
%<*internal>
\iffalse
%</internal>
%<*readme>
----------------------------------------------------------------
penrose --- TikZ library for producing tiling patterns
E-mail: loopspace@mathforge.org
Released under the LaTeX Project Public License v1.3c or later
See http://www.latex-project.org/lppl.txt
----------------------------------------------------------------

This package is for the creation of Penrose and similar tilings.
%</readme>
%<*internal>
\fi
\def\nameofplainTeX{plain}
\ifx\fmtname\nameofplainTeX\else
  \expandafter\begingroup
\fi
%</internal>
%<*install>
\input l3docstrip.tex
\keepsilent
\askforoverwritefalse
\preamble
----------------------------------------------------------------
tilings --- TikZ library for producing tilings
E-mail: loopspace@mathforge.org
Released under the LaTeX Project Public License v1.3c or later
See http://www.latex-project.org/lppl.txt
----------------------------------------------------------------

\endpreamble
\postamble

Copyright (C) 2014-2023 by Andrew Stacey <loopspace@mathforge.org>

This work may be distributed and/or modified under the
conditions of the LaTeX Project Public License (LPPL), either
version 1.3c of this license or (at your option) any later
version.  The latest version of this license is in the file:

http://www.latex-project.org/lppl.txt

This work is "maintained" (as per LPPL maintenance status) by
Andrew Stacey.

This work consists of the files  penrose_code.dtx
                                 penrose.tex
and the derived files            penrose.ins
                                 penrose_code.pdf
                                 penrose.pdf
                                 tikzlibrarytilings.code.tex
                                 tikzlibrarytilings.penrose.code.tex
                                 tikzlibrarytilings.polykite.code.tex
                                 tikzlibrarypenrose.code.tex
                                 README.txt

\endpostamble
\usedir{tex/latex/penrose}
\generate{
  \file{tikzlibrarytilings.code.tex}{\from{\jobname.dtx}{tilings}}
}
\generate{
  \file{tikzlibrarytilings.penrose.code.tex}{\from{\jobname.dtx}{penrose}}
}
\generate{
  \file{tikzlibrarytilings.polykite.code.tex}{\from{\jobname.dtx}{polykite}}
}
\generate{
  \file{tikzlibrarypenrose.code.tex}{\from{\jobname.dtx}{penrosedep}}
}
%</install>
%<install>\endbatchfile
%<*internal>
\usedir{source/latex/penrose}
\generate{
  \file{\jobname.ins}{\from{\jobname.dtx}{install}}
}
\nopreamble\nopostamble
\usedir{doc/latex/penrose}
\generate{
  \file{README.txt}{\from{\jobname.dtx}{readme}}
}
\ifx\fmtname\nameofplainTeX
  \expandafter\endbatchfile
\else
  \expandafter\endgroup
\fi
%</internal>
%<*driver>
\documentclass{l3doc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{tikz}
\usepackage{amsmath}
%\usepackage{trace}
\usetikzlibrary{penrose}
%\traceoff
%\usepackage[numbered]{hypdoc}
\definecolor{lstbgcolor}{rgb}{0.9,0.9,0.9} 
 
\usepackage{listings}
\lstloadlanguages{[LaTeX]TeX}
\lstset{breakatwhitespace=true,breaklines=true,language=TeX}
 
\usepackage{fancyvrb}

\newenvironment{example}
  {\VerbatimEnvironment
   \begin{VerbatimOut}[gobble=2]{example.out}}
  {\end{VerbatimOut}
   \begin{center}
%   \setlength{\parindent}{0pt}
   \fbox{\begin{minipage}{.9\linewidth}
     \lstset{breakatwhitespace=true,breaklines=true,language=TeX,basicstyle=\small}
     \lstinputlisting[]{example.out}
   \end{minipage}}

   \fbox{\begin{minipage}{.9\linewidth}
     \input{example.out}
   \end{minipage}}
\end{center}
}
\EnableCrossrefs
\CodelineIndex
\RecordChanges
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% \CheckSum{2944}
%
% \CharacterTable
%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%   Digits        \0\1\2\3\4\5\6\7\8\9
%   Exclamation   \!     Double quote  \"     Hash (number) \#
%   Dollar        \$     Percent       \%     Ampersand     \&
%   Acute accent  \'     Left paren    \(     Right paren   \)
%   Asterisk      \*     Plus          \+     Comma         \,
%   Minus         \-     Point         \.     Solidus       \/
%   Colon         \:     Semicolon     \;     Less than     \<
%   Equals        \=     Greater than  \>     Question mark \?
%   Commercial at \@     Left bracket  \[     Backslash     \\
%   Right bracket \]     Circumflex    \^     Underscore    \_
%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%   Right brace   \}     Tilde         \~}
%
%
% \changes{1.0}{2014/05/07}{Converted to DTX file}
% \changes{1.2}{2019/02/23}{Added general tile creation code}
% \changes{1.4}{2021/01/22}{Adapted to latest version of spath3}
% \changes{1.6}{2023/03/22}{Included aperiodical hat}
%
% \DoNotIndex
%   {
%     \begingroup,
%     \catcode,
%     \active,
%     \csname,
%     \endcsname,
%   }%
%
%
% \providecommand*{\url}{\texttt}
% \GetFileInfo{tikzlibrarypenrose.code.tex}
% \title{The \textsf{Penrose} package}
% \author{Andrew Stacey\texorpdfstring{\\ \url{loopspace@mathforge.org}}{}}
% \date{\fileversion~from \filedate}
%
%
% \maketitle
%
% \tableofcontents
%
% \begin{documentation}
% 
% \section{Introduction}
%
% This is a TikZ library for drawing Penrose tiles (kite/dart, rhombus, and pentagon versions).
% It provides two methods of drawing: one in which an automatic pattern is built, and one where the tiles can be placed ``by hand''.
% The tiles can be shaped and (hopefully!) still fit together.
% For full user documentation, see the \Verb+penrose.pdf+ file.
%
%
% \end{documentation}
%
% \begin{implementation}
%
% \section{Implementation}
%
% 
% \iffalse
%<*tilings>
% \fi
%
%    \begin{macrocode}
%<@@=tilings>
%    \end{macrocode}
%
% \subsection{Initialisation}
%
%
% We use the \Verb+spath3+ library for manipulating the paths that will make up the tiles.
%
%    \begin{macrocode}
\ProvidesExplFile {tikzlibrarytilings.code.tex} {2023/03/22} {1.6} {TikZ pics for tilings such as Penrose tiles}
\RequirePackage{tikz}
\usetikzlibrary{spath3}
%    \end{macrocode}
% Now we move in to the realm of \LaTeX3.
%    \begin{macrocode}
\ExplSyntaxOn
%    \end{macrocode}
%
% Start with some basic paths (lines) for the sides of the tiles so that we know that we have well-defined tiles at the outset.
% These are globally defined as we will frequently want to define them in one tikzpicture and use them in another.
%
%    \begin{macrocode}
\tl_new:N \g_@@_side_a_tl
\tl_new:N \g_@@_side_b_tl
\tl_new:N \g_@@_side_c_tl
\tl_new:N \g_@@_side_d_tl
\tl_new:N \g_@@_side_e_tl
\tl_new:N \g_@@_side_A_tl
\tl_new:N \g_@@_side_B_tl
\tl_new:N \g_@@_side_C_tl
\tl_new:N \g_@@_side_D_tl
\tl_new:N \g_@@_side_E_tl
\tl_new:c {g_@@_side_1_tl}
\tl_new:c {g_@@_side_2_tl}
\tl_new:c {g_@@_side_3_tl}
\tl_gset:Nn \g_@@_side_a_tl
{
  \pgfsyssoftpath@movetotoken{0pt}{0pt}
  \pgfsyssoftpath@linetotoken{1pt}{0pt}
}
\tl_gset_eq:NN \g_@@_side_b_tl \g_@@_side_a_tl
\tl_gset_eq:NN \g_@@_side_c_tl \g_@@_side_a_tl
\tl_gset_eq:NN \g_@@_side_d_tl \g_@@_side_a_tl
\tl_gset_eq:NN \g_@@_side_e_tl \g_@@_side_a_tl
\tl_gset_eq:NN \g_@@_side_A_tl \g_@@_side_a_tl
\tl_gset_eq:NN \g_@@_side_B_tl \g_@@_side_a_tl
\tl_gset_eq:NN \g_@@_side_C_tl \g_@@_side_a_tl
\tl_gset_eq:NN \g_@@_side_D_tl \g_@@_side_a_tl
\tl_gset_eq:NN \g_@@_side_E_tl \g_@@_side_a_tl
\tl_gset_eq:cN {g_@@_side_1_tl} \g_@@_side_a_tl
\tl_gset_eq:cN {g_@@_side_2_tl} \g_@@_side_a_tl
\tl_gset_eq:cN {g_@@_side_3_tl} \g_@@_side_a_tl
%    \end{macrocode}
%
% \begin{variable}{\l_@@_tmpa_fp, \l_@@_tmpb_fp, \l_@@_tmpc_fp, \l_@@_saved_x_fp, \l_@@_saved_y_fp, \l_@@_tmpa_str, \l_@@_tmpb_str, \l_@@_tmpa_seq, \l_@@_tmpa_tl, \l_@@_tmpb_tl, \l_@@_tmpc_tl, \l_@@_tmpd_tl, \l_@@_tmpa_int, \l_@@_tmpb_int, \l_@@_xa_dim, \l_@@_ya_dim, \l_@@_xb_dim, \l_@@_yb_dim, \g_@@_xa_dim, \g_@@_ya_dim, \g_@@_xb_dim, \g_@@_yb_dim, \l_@@_tmpa_prop, \l_@@_cw_bool, \l_@@_update_saved_bool, \l_@@_relative_bool, \g_@@_output_tl}
% We need a few temporary variables to hold intermediate calculations.
%
%    \begin{macrocode}
\fp_new:N \l_@@_tmpa_fp
\fp_new:N \l_@@_tmpb_fp
\fp_new:N \l_@@_tmpc_fp
\fp_new:N \l_@@_saved_x_fp
\fp_new:N \l_@@_saved_y_fp
\str_new:N \l_@@_tmpa_str
\str_new:N \l_@@_tmpb_str
\seq_new:N \l_@@_tmpa_seq
\tl_new:N \l_@@_tmpa_tl
\tl_new:N \l_@@_tmpb_tl
\tl_new:N \l_@@_tmpc_tl
\tl_new:N \l_@@_tmpd_tl
\tl_new:N \l_@@_tmp_tile_path_tl
\int_new:N \l_@@_tmpa_int
\int_new:N \l_@@_tmpb_int
\fp_new:N \l_@@_xa_fp
\fp_new:N \l_@@_ya_fp
\fp_new:N \l_@@_xb_fp
\fp_new:N \l_@@_yb_fp
\dim_new:N \l_@@_xa_dim
\dim_new:N \l_@@_ya_dim
\dim_new:N \l_@@_xb_dim
\dim_new:N \l_@@_yb_dim
\dim_new:N \g_@@_xa_dim
\dim_new:N \g_@@_ya_dim
\dim_new:N \g_@@_xb_dim
\dim_new:N \g_@@_yb_dim
\prop_new:N \l_@@_tmpa_prop
\bool_new:N \l_@@_cw_bool
\bool_new:N \l_@@_update_saved_bool
\bool_new:N \l_@@_relative_bool
\bool_new:N \l_@@_edge_bool
\str_const:Nn \c_@@_colon_str {:}
\str_const:Nn \c_@@_comma_str {,}
\fp_const:Nn \c_@@_cm_fp {\dim_to_fp:n {1cm}}
\tl_new:N \g_@@_output_tl
\fp_new:N \g_@@_output_a_fp
\fp_new:N \g_@@_output_b_fp
\cs_generate_variant:Nn \seq_set_split:Nnn {NVV}
%    \end{macrocode}
% \end{variable}
%
% \subsection{Helpful Error Messages}
%
%    \begin{macrocode}
\msg_new:nnn { tilings }{ not baked }{ Tile~ #1~ has~ not~ been~ baked. }
\msg_new:nnn { tilings }{ no tile }{ Tile~ #1~ has~ not~ been~ defined. }
\msg_new:nnn { tilings }{ no side }{ Tile~ side~ #1~ has~ not~ been~ defined,~ using~ default. }
\msg_new:nnn { tilings }{ tile no edge }{ Tile~ #1~ doesn't~ have~ an~ edge~ labelled~ #2;~ available~ edges~ are~ #3.}
\msg_new:nnn { tilings }{ no edge }{ Either~ tile~ #1~ doesn't~ exist~ or~ it~ doesn't~ have~ an~ edge~ labelled~ #2.}
%    \end{macrocode}
%
% \subsection{Creating the Tiles}
%
% \begin{macro}[internal]{\@@_normalise_path:Nn}
% When defining the path for a side, we normalise so that it starts at the origin and ends at \Verb+(1pt,0pt)+.
%    \begin{macrocode}
\cs_new_nopar:Npn \@@_normalise_path:Nn #1#2
{
%    \end{macrocode}
% Get the initial point of the path and convert to floating point.
%    \begin{macrocode}
  \group_begin:
  \spath_initialpoint:Nn \l_@@_tmpa_tl {#2}
  \fp_set:Nn \l_@@_tmpa_fp {\tl_head:N \l_@@_tmpa_tl}
  \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
  \fp_set:Nn \l_@@_tmpb_fp {\tl_head:N \l_@@_tmpa_tl}
%    \end{macrocode}
% Get the final point of the path, and compute the difference of the final and initial points.
%
% The resulting numbers, say \(a\) and \(b\), will be put into a matrix to rotate and scale the path.
% The formula for the matrix is:
%^^A
% \[
% \frac{1}{a^2 + b^2}
% \begin{bmatrix} a & b \\ -b & a \end{bmatrix}
% \]
%
%    \begin{macrocode}
  \spath_finalpoint:Nn \l_@@_tmpa_tl {#2}
  \fp_set:Nn \l_@@_tmpa_fp
  {\tl_head:N \l_@@_tmpa_tl - \l_@@_tmpa_fp}
  \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
  \fp_set:Nn \l_@@_tmpb_fp
  {\tl_head:N \l_@@_tmpa_tl - \l_@@_tmpb_fp}
%    \end{macrocode}
% Now compute the square of the length of the path for scaling.
%    \begin{macrocode}
  \fp_set:Nn \l_@@_tmpc_fp
  {\l_@@_tmpa_fp^2 + \l_@@_tmpb_fp^2}
  \fp_set:Nn \l_@@_tmpa_fp {\l_@@_tmpa_fp/\l_@@_tmpc_fp}
  \fp_set:Nn \l_@@_tmpb_fp {\l_@@_tmpb_fp/\l_@@_tmpc_fp}
  \fp_set:Nn \l_@@_tmpc_fp {-\l_@@_tmpb_fp}
%    \end{macrocode}
% Now construct the matrix.
%    \begin{macrocode}
  \tl_set:Nx \l_@@_tmpb_tl
  {
    {\fp_use:N \l_@@_tmpa_fp}
    {\fp_use:N \l_@@_tmpc_fp} % swapped
    {\fp_use:N \l_@@_tmpb_fp} % swapped
    {\fp_use:N \l_@@_tmpa_fp}
  }
%    \end{macrocode}
% Get the initial point back again for the translation part.
%    \begin{macrocode}
  \spath_initialpoint:Nn \l_@@_tmpa_tl {#2}
%    \end{macrocode}
% But we need to premultiply by the matrix because of how the transformations are applied.
%    \begin{macrocode}
  \fp_set:Nn \l_@@_tmpa_fp
  {
    (-1) * \l_@@_tmpa_fp * \tl_head:N \l_@@_tmpa_tl
    + (-1) * \l_@@_tmpb_fp * \tl_tail:N \l_@@_tmpa_tl
  }
  \fp_set:Nn \l_@@_tmpb_fp
  {
    (-1) * \l_@@_tmpa_fp * \tl_tail:N \l_@@_tmpa_tl
    +  \l_@@_tmpb_fp * \tl_head:N \l_@@_tmpa_tl
  }
%    \end{macrocode}
% Finally, we apply the transformation to the path.
%    \begin{macrocode}
  \tl_put_right:Nx \l_@@_tmpb_tl {
    {\fp_to_dim:N \l_@@_tmpa_fp}
    {\fp_to_dim:N \l_@@_tmpb_fp}
  }
  \spath_transform:NnV \l_@@_tmpa_tl {#2} \l_@@_tmpb_tl
  \tl_gset_eq:NN \g_@@_output_tl \l_@@_tmpa_tl
  \group_end:
  \tl_set_eq:NN #1 \g_@@_output_tl
  \tl_gclear:N \g_@@_output_tl
}
\cs_generate_variant:Nn \@@_normalise_path:Nn {NV, cn, cV}
\cs_new_protected_nopar:Npn \@@_normalise_path:N #1
{
  \@@_normalise_path:NV #1#1
}
\cs_generate_variant:Nn \@@_normalise_path:N {c}
%    \end{macrocode}
% \end{macro}
%
% \begin{function}{\SetTilingPath}
% This sets the path corresponding to a particular side to the current path, and normalises it.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_set_tiling_path:n #1
{
  \group_begin:
  \pgfsyssoftpath@getcurrentpath\l_@@_tmpa_tl
  \@@_normalise_path:N \l_@@_tmpa_tl
  \tl_gset_eq:cN {g_@@_side_#1_tl} \l_@@_tmpa_tl
  \group_end:
}

\NewDocumentCommand \SetTilingPath { m }
{
  \@@_set_tiling_path:n {#1}
}
%    \end{macrocode}
% \end{function}
%
% \begin{macro}[internal]{\tikz_scan_point:n}
% This is a wrapper around \Verb+\tikz@scan@one@point+ to make it easier to use with \LaTeX3 variables.
%    \begin{macrocode}
\cs_new_nopar:Npn \tikz_scan_point:n #1
{
  \tikz@scan@one@point\pgfutil@firstofone#1\relax
}
\cs_generate_variant:Nn \tikz_scan_point:n {V}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\tikz_node_if_defined:TF}
% This extracts the code that tests if a node is defined.
%    \begin{macrocode}
\prg_new_conditional:Npnn \tikz_node_if_defined:n #1 {p,T,F,TF}
{
  \tl_if_exist:cTF {pgf@sh@ns@\use:c{tikz@pp@name}{#1}}
  {
    \prg_return_true:
  }{
    \tl_if_exist:cTF {pgf@sh@ns@not yet positionedPGFINTERNAL\use:c{tikz@pp@name}{#1}}
    {
      \pgf_return_true:
    }
    {
      \prg_return_false:
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\@@_keys_get:Nn,\pgfkeys_get:n}
% This is a wrapper around \Verb+\pgfkeysgetvalue+ to make it easier to use with \LaTeX3 variables.
%    \begin{macrocode}
\cs_new_nopar:Npn \@@_keys_get:Nn #1#2
{
  \pgfkeysgetvalue{/tikz/tiling/#2}{#1}
}
\cs_new_nopar:Npn \@@_keys_get:n #1
{
  \pgfkeysvalueof{/tikz/tiling/#1}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\@@_make_tile:nnn}
% This builds the tile path from its pieces.
% The arguments are the name of the tile, the descriptions of the sides, and a token list of the coordinates.
%    \begin{macrocode}
\cs_new_nopar:Npn \@@_make_tile:nnn #1#2#3
{
%    \end{macrocode}
% Get the first coordinate and initialise the path with a move to this point.
%    \begin{macrocode}
  \group_begin:
  \tl_set:Nn \l_@@_tmpa_tl {#3}
  \tl_set:Nx \l_@@_tmpb_tl {\tl_head:N \l_@@_tmpa_tl}
  \tl_set:Nn \l_@@_tmpa_tl {\pgfsyssoftpath@movetotoken}
  \tl_put_right:Nx \l_@@_tmpa_tl
  {
    {\fp_to_dim:n {(\tl_item:Nn \l_@@_tmpb_tl {1}) * \c_@@_cm_fp}}
    {\fp_to_dim:n {(\tl_item:Nn \l_@@_tmpb_tl {2}) * \c_@@_cm_fp}}
  }
  \tl_set_eq:NN \l_@@_tmp_tile_path_tl \l_@@_tmpa_tl
%    \end{macrocode}
% Now we have our path initialised, we can start appending the side paths according to the specification in the second argument.
%
% We append the initial coordinate to the end of the list to make a closed cycle.
%    \begin{macrocode}
  \tl_set:Nn \l_@@_tmpa_tl {#3}
  \tl_put_right:Nx \l_@@_tmpa_tl {{\tl_head:N \l_@@_tmpa_tl}}
%    \end{macrocode}
% Now we walk through the description of the sides, adding the specified paths to our tile path.
%    \begin{macrocode}
  \tl_map_inline:nn {#2} {
%    \end{macrocode}
% Clone the path for this side.
%    \begin{macrocode}
    \tl_set:Nx \l_@@_tmpc_tl {\tl_head:n {##1}}
    \tl_if_exist:cF {g_@@_side_ \tl_use:N \l_@@_tmpc_tl _tl}
    {
      \msg_error:nnx { tilings }{ no side } { \tl_use:N \l_@@_tmpc_tl }
      \tl_gset_eq:cc {g_@@_side_ \tl_use:N \l_@@_tmpc_tl _tl} {g_@@_side_a_tl}
    }
    \tl_set_eq:Nc \l_@@_tmpd_tl {g_@@_side_ \tl_use:N \l_@@_tmpc_tl _tl}
%    \end{macrocode}
% Strip off the next coordinate, and convert it to a point.
%    \begin{macrocode}
    \tl_set:Nx \l_@@_tmpb_tl {\tl_head:N \l_@@_tmpa_tl}
    \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
%    \end{macrocode}
% Store the resulting coordinate.
%    \begin{macrocode}
    \fp_set:Nn \l_@@_tmpa_fp { \tl_item:Nn \l_@@_tmpb_tl {1} }
    \fp_set:Nn \l_@@_tmpb_fp { \tl_item:Nn \l_@@_tmpb_tl {2} }
%    \end{macrocode}
% Now get the next coordinate.
%    \begin{macrocode}
    \tl_set:Nx \l_@@_tmpb_tl {\tl_head:N \l_@@_tmpa_tl}
%    \end{macrocode}
% We want the difference between the two coordinates.
%    \begin{macrocode}
    \fp_set:Nn \l_@@_tmpa_fp {\tl_item:Nn \l_@@_tmpb_tl {1} - \l_@@_tmpa_fp}
    \fp_set:Nn \l_@@_tmpb_fp {\tl_item:Nn \l_@@_tmpb_tl {2} - \l_@@_tmpb_fp}
%    \end{macrocode}
% This is converted into a transformation matrix.
%    \begin{macrocode}
    \fp_set:Nn \l_@@_tmpc_fp {-\l_@@_tmpb_fp}
    \tl_set:Nx \l_@@_tmpb_tl
    {
      {\fp_to_dim:n { \l_@@_tmpa_fp * \c_@@_cm_fp }}
      {\fp_to_dim:n { \l_@@_tmpb_fp * \c_@@_cm_fp }} % not swapped
      {\fp_to_dim:n { \l_@@_tmpc_fp * \c_@@_cm_fp }} % not swapped
      {\fp_to_dim:n { \l_@@_tmpa_fp * \c_@@_cm_fp }}
      {0}
      {0}
    }
%    \end{macrocode}
% The transformation is applied to the cloned path.
%    \begin{macrocode}
    \spath_transform:NV \l_@@_tmpd_tl \l_@@_tmpb_tl
%    \end{macrocode}
% And this is welded to the tile path.
%    \begin{macrocode}
    \spath_weld:NV \l_@@_tmp_tile_path_tl \l_@@_tmpd_tl
  }
%    \end{macrocode}
% At the end we close the path.
%    \begin{macrocode}
  \spath_close:N \l_@@_tmp_tile_path_tl
  \tl_gset_eq:NN \g_@@_output_tl \l_@@_tmp_tile_path_tl
  \group_end:
  \tl_gclear_new:c {g_@@_tile_#1_tl}
  \tl_gset_eq:cN {g_@@_tile_#1_tl} \g_@@_output_tl
  \tl_gclear:N \g_@@_output_tl
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\@@_make_tile:nn}
% A wrapper around the above which allows us to specify the second two arguments as two items in a token list.
%    \begin{macrocode}
\cs_new_nopar:Npn \@@_make_tile:nn #1#2
{
  \@@_make_tile:nnn {#1} #2
}
\cs_generate_variant:Nn \@@_make_tile:nn {nV}
%    \end{macrocode}
% \end{macro}
%
% \subsection{Specifying the Tiles}
%
% The tile specifications are contained in a \Verb+prop+.
%    \begin{macrocode}
\prop_new:N \g_@@_tiles_prop
%    \end{macrocode}
%
% \begin{macro}[internal]{\@@_add_coordinate:Nnn, \@@_add_coordinate:w}
% Process a coordinate through \Verb+fp+ and adds it to a token list.
%    \begin{macrocode}
\cs_new_nopar:Npn \@@_add_coordinate:Nnn #1#2#3 {
  \group_begin:
  \fp_set:Nn \l_@@_tmpa_fp {#2}
  \fp_set:Nn \l_@@_tmpb_fp {#3}
  \bool_if:NT \l_@@_relative_bool
  {
    \fp_add:Nn \l_@@_tmpa_fp {\l_@@_saved_x_fp}
    \fp_add:Nn \l_@@_tmpb_fp {\l_@@_saved_y_fp}
  }
  \fp_gset_eq:NN \g_@@_output_a_fp \l_@@_tmpa_fp
  \fp_gset_eq:NN \g_@@_output_b_fp \l_@@_tmpb_fp
  \group_end:
  \tl_put_right:Nx #1
  {
    {{\fp_use:N \g_@@_output_a_fp}{\fp_use:N \g_@@_output_b_fp}}
  }
  \bool_if:NT \l_@@_update_saved_bool
  {
    \fp_set_eq:NN \l_@@_saved_x_fp \g_@@_output_a_fp
    \fp_set_eq:NN \l_@@_saved_y_fp \g_@@_output_b_fp
  }
  \fp_gzero:N \g_@@_output_a_fp
  \fp_gzero:N \g_@@_output_b_fp
}
%    \end{macrocode}
% Wrapper around the add coordinate command to split at a comma.
%    \begin{macrocode}
\cs_new_nopar:Npn \@@_add_xy_coordinate:w #1#2,#3 \q_stop
{
  \@@_add_coordinate:Nnn #1 {#2}{#3}
}
%    \end{macrocode}
% \end{macro}
%
% Wrapper around the add coordinate command to split at a colon.
%    \begin{macrocode}
\cs_new_nopar:Npn \@@_add_rth_coordinate:w #1#2:#3 \q_stop
{
  \@@_add_coordinate:Nnn #1 {(#3) * cosd(#2)}{(#3) * sind(#2)}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\@@_transform_side_to_axis:Nnn}
% Apply a transformation to make a given side lie on the x-axis.
% Second argument is the tile, third is the side, first is whether to reverse the side.
%    \begin{macrocode}
\cs_new_nopar:Npn \@@_transform_side_to_axis:Nnn #1#2#3
{
%    \end{macrocode}
% Get our tile data, checking if the tile exists.
%    \begin{macrocode}
  \group_begin:
  \prop_get:NnNTF \g_@@_tiles_prop {#2} \l_@@_tmpa_tl
  {
%    \end{macrocode}
% Start with the edge list.
%
% Initialise the counter.
%    \begin{macrocode}
  \int_zero:N \l_@@_tmpb_int
  \int_incr:N \l_@@_tmpb_int
%    \end{macrocode}
% Get the path type list.
%
%    \begin{macrocode}
  \tl_set:Nx \l_@@_tmpc_tl {\tl_head:N \l_@@_tmpa_tl}
%    \end{macrocode}
%
% Iterate through the path type list, looking for the requested path.
%    \begin{macrocode}
    \bool_set_false:N \l_@@_edge_bool
    \tl_map_inline:Nn \l_@@_tmpc_tl {
      \str_if_eq:nnT {##1} {#3} {
        \bool_set_true:N \l_@@_edge_bool
        \tl_map_break:
      }
      \int_incr:N \l_@@_tmpb_int
    }
    \bool_if:NTF \l_@@_edge_bool
    {
%    \end{macrocode}
% Get the coordinate list.
%    \begin{macrocode}
      \tl_set:Nx \l_@@_tmpc_tl {\tl_tail:N \l_@@_tmpa_tl}
%    \end{macrocode}
% Strip off the outer braces.
%    \begin{macrocode}
      \tl_set:Nx \l_@@_tmpc_tl {\tl_item:Nn \l_@@_tmpc_tl {1}}
%    \end{macrocode}
% Add the first coordinate at the end.
%    \begin{macrocode}
      \tl_put_right:Nx \l_@@_tmpc_tl
      {{\tl_item:Nn \l_@@_tmpc_tl {1}}}
%    \end{macrocode}
% Get the coordinates for this edge.
%    \begin{macrocode}
      \tl_set:Nx \l_@@_tmpa_tl
      {\tl_item:Nn \l_@@_tmpc_tl {\int_use:N \l_@@_tmpb_int}}
      \tl_set:Nx \l_@@_tmpb_tl
      {\tl_item:Nn \l_@@_tmpc_tl {\int_use:N \l_@@_tmpb_int + 1}}
%    \end{macrocode}
% Possibly swap the ends.
%    \begin{macrocode}
      \bool_if:NT #1
      {
        \tl_set:NV \l_@@_tmpc_tl \l_@@_tmpa_tl
        \tl_set:NV \l_@@_tmpa_tl \l_@@_tmpb_tl
        \tl_set:NV \l_@@_tmpb_tl \l_@@_tmpc_tl
      }
%    \end{macrocode}
% Get the coordinates of the first point, which will be the origin of the transformation.
%    \begin{macrocode}
      \fp_set:Nn \l_@@_xa_fp {\tl_item:Nn \l_@@_tmpb_tl {1}}
      \fp_set:Nn \l_@@_ya_fp {\tl_item:Nn \l_@@_tmpb_tl {2}}
%    \end{macrocode}
% Get the coordinates of the second point and adjust relative to the first.
%    \begin{macrocode}
      \fp_set:Nn \l_@@_xb_fp {\tl_item:Nn \l_@@_tmpa_tl {1} - \l_@@_xa_fp}
      \fp_set:Nn \l_@@_yb_fp {\tl_item:Nn \l_@@_tmpa_tl {2} - \l_@@_ya_fp}
%    \end{macrocode}
% And normalise the vector along it.
%    \begin{macrocode}
%  \fp_set:Nn \l_@@_xb_fp {\l_@@_xb_fp / \c_@@_cm_fp}
%  \fp_set:Nn \l_@@_yb_fp {\l_@@_yb_fp / \c_@@_cm_fp}
      \fp_set:Nn \l_@@_tmpa_fp {(\l_@@_xb_fp)^2 + (\l_@@_yb_fp)^2}
      \fp_set:Nn \l_@@_xb_fp { \l_@@_xb_fp / \l_@@_tmpa_fp}
      \fp_set:Nn \l_@@_yb_fp { \l_@@_yb_fp / \l_@@_tmpa_fp}
%    \end{macrocode}
% Now rotate so that the \(x\)--axis lies along the edge.
%    \begin{macrocode}
      \tl_gset:Nx \g_@@_output_tl
      {
        \exp_not:N \pgftransformtriangle
        {
          \exp_not:N \pgfpoint{0pt}{0pt}
        }
        {
          \exp_not:N \pgfpoint
          {\fp_to_dim:N \l_@@_xb_fp}{\fp_to_dim:n {-\l_@@_yb_fp}}
        }
        {
          \exp_not:N \pgfpoint
          {\fp_to_dim:N \l_@@_yb_fp}{\fp_to_dim:N \l_@@_xb_fp}
        }
        \exp_not:N \pgftransformshift
        {
          \exp_not:N \pgfpoint
          {
            \fp_to_dim:n {-\l_@@_xa_fp * \c_@@_cm_fp}
          }
          {
            \fp_to_dim:n {-\l_@@_ya_fp * \c_@@_cm_fp}
          }
        }
      }
    }
    {
      \msg_error:nnxxx {tilings} {tile no edge} {#2} {#3} {\tl_use:N  \l_@@_tmpc_tl }
      \tl_gclear:N \g_@@_output_tl
    }
  }
  {
    \msg_error:nnn {tilings} {no tile} {#2}
    \tl_gclear:N \g_@@_output_tl
  }
  \group_end:
  \tl_use:N \g_@@_output_tl
  \tl_gclear:N \g_@@_output_tl
}
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
\cs_generate_variant:Nn \tl_if_eq:nnT {nVT}
\cs_generate_variant:Nn \@@_transform_side_to_axis:Nnn {Nnx,NnV,NVV}
%    \end{macrocode}
%
% \begin{macro}[internal]{\TransformAlongSide}
% Make this available outside the \LaTeX3 environment.
% The starred version allows for reversing the side.
%    \begin{macrocode}
\DeclareDocumentCommand \TransformAlongSide {s m m}
{
%    \end{macrocode}
% Store the star
%    \begin{macrocode}
  \IfBooleanTF {#1}
  {
    \bool_set_true:N \l_@@_cw_bool
  }
  {
    \bool_set_false:N \l_@@_cw_bool
  }
  \@@_transform_side_to_axis:Nnx \l_@@_cw_bool {#2}{#3}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\@@_coordinates_at_vertices:n}
% This places TikZ coordinates at the vertices of the tile.
%    \begin{macrocode}
\cs_new_nopar:Npn \@@_coordinates_at_vertices:n #1
{
  \group_begin:
%    \end{macrocode}
% Get our tile data
%    \begin{macrocode}
  \prop_get:NnN \g_@@_tiles_prop {#1} \l_@@_tmpa_tl
%    \end{macrocode}
% Start with the edge list
%    \begin{macrocode}
  \tl_set:Nx \l_@@_tmpb_tl {\tl_head:N \l_@@_tmpa_tl}
%    \end{macrocode}
% Get the coordinate list
%    \begin{macrocode}
  \tl_set:Nx \l_@@_tmpc_tl {\tl_tail:N \l_@@_tmpa_tl}
%    \end{macrocode}
% Strip off the outer braces
%    \begin{macrocode}
  \tl_set:Nx \l_@@_tmpc_tl
  {\tl_item:Nn \l_@@_tmpc_tl {1}}
%    \end{macrocode}
% Add the first coordinate at the end
%    \begin{macrocode}
  \tl_put_right:Nx \l_@@_tmpc_tl
  {{\tl_item:Nn \l_@@_tmpc_tl {1}}}
%    \end{macrocode}
% Get the first coordinate
%    \begin{macrocode}
  \tl_set:Nx \l_@@_tmpa_tl {\tl_head:N \l_@@_tmpc_tl}
  \tl_set:Nx \l_@@_tmpc_tl {\tl_tail:N \l_@@_tmpc_tl}
%    \end{macrocode}
% Iterate through the path type list, looking for the requested path
%    \begin{macrocode}
  \tl_map_inline:Nn \l_@@_tmpb_tl {
    \tl_set:Nx \l_@@_tmpd_tl {
      \exp_not:N \coordinate
      (-edge~ ##1~ start)~ at (\tl_item:Nn \l_@@_tmpa_tl {1},\tl_item:Nn \l_@@_tmpa_tl {2});
    }
    \tl_use:N \l_@@_tmpd_tl
    \tl_set:Nx \l_@@_tmpa_tl {\tl_head:N \l_@@_tmpc_tl}
    \tl_set:Nx \l_@@_tmpc_tl {\tl_tail:N \l_@@_tmpc_tl}
    \tl_set:Nx \l_@@_tmpd_tl {
      \exp_not:N \coordinate
      (-edge~ ##1~ end)~ at (\tl_item:Nn \l_@@_tmpa_tl {1},\tl_item:Nn \l_@@_tmpa_tl {2});
    }
    \tl_use:N \l_@@_tmpd_tl
  }
  \group_end:
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\CoordinatesAtVertices}
% User-accessible wrapper around the above.
%    \begin{macrocode}
\DeclareDocumentCommand \CoordinatesAtVertices {m}
{
  \@@_coordinates_at_vertices:n {#1}
}
%    \end{macrocode}
% \end{macro}
%
%
%    \begin{macrocode}
\tikzset{
  transform~ to~ tile/.code~ args={#1~ along~ #2}{%
    \group_begin:
    \tl_if_in:nnTF {#1} {back}
    {
      \tikzset{
        tiling/alignment~ set~ location=#1,
        tiling/alignment~ direction={backwards}
      }
    }
    {
      \tikzset{
        tiling/alignment~ location=#1,
        tiling/alignment~ direction={forewards}
      }
    }
    \tl_if_in:nnTF {#2} {using}
    {
      \tikzset{
        tiling/alignment~ set~ edges=#2,
      }
    }
    {
      \tikzset{
        tiling/alignment~ edge=#2,
      }
    }
    \tikz_scan_point:n {
      (\@@_keys_get:n {alignment~ location} -edge~ \@@_keys_get:n {alignment~ edge}~ start)
    }
    \dim_set_eq:Nc \l_@@_xa_dim {pgf@x}
    \dim_set_eq:Nc \l_@@_ya_dim {pgf@y}
    \tikz_scan_point:n {
      (\@@_keys_get:n {alignment~ location} -edge~ \@@_keys_get:n {alignment~ edge}~ end)
    }
    \dim_set_eq:Nc \l_@@_xb_dim {pgf@x}
    \dim_set_eq:Nc \l_@@_yb_dim {pgf@y}
    \@@_keys_get:Nn \l_@@_tmpb_tl {alignment~ direction}
    \tl_if_eq:NnTF \l_@@_tmpb_tl {forewards}
    {
      \dim_gset_eq:NN \g_@@_xa_dim \l_@@_xa_dim
      \dim_gset_eq:NN \g_@@_ya_dim \l_@@_ya_dim
      \dim_gset_eq:NN \g_@@_xb_dim \l_@@_xb_dim
      \dim_gset_eq:NN \g_@@_yb_dim \l_@@_yb_dim
    }
    {
      \dim_gset_eq:NN \g_@@_xa_dim \l_@@_xb_dim
      \dim_gset_eq:NN \g_@@_ya_dim \l_@@_yb_dim
      \dim_gset_eq:NN \g_@@_xb_dim \l_@@_xa_dim
      \dim_gset_eq:NN \g_@@_yb_dim \l_@@_ya_dim
    }
    \dim_gsub:Nn \g_@@_xb_dim {\g_@@_xa_dim}
    \dim_gsub:Nn \g_@@_yb_dim {\g_@@_ya_dim}
    \dim_gset:Nn \g_@@_xb_dim {\g_@@_xb_dim * \dim_ratio:nn {1pt}{1cm}}
    \dim_gset:Nn \g_@@_yb_dim {\g_@@_yb_dim * \dim_ratio:nn {1pt}{1cm}}
    \group_end:
%    \end{macrocode}
% We store the initial points in \Verb+\pgf@xa+ and \Verb+\pgf@ya+ but we want \Verb+\pgf@xb+ and \Verb+\pgf@yb+ to be a vector along the edge.
%    \begin{macrocode}
%    \end{macrocode}
% We shift to the start of the edge.
%    \begin{macrocode}
    \pgftransformshift{\pgfpoint{\g_@@_xa_dim}{\g_@@_ya_dim}}
%    \end{macrocode}
% Now rotate so that the \(x\)--axis lies along the edge.
%    \begin{macrocode}
    \pgftransformtriangle
    {\pgfpoint{0pt}{0pt}}
    {\pgfpoint{\g_@@_xb_dim}{\g_@@_yb_dim}}
    {\pgfpoint{-\g_@@_yb_dim}{\g_@@_xb_dim}}
  },
  align~ with/.code~ args={#1~ along~ #2}{%
    \tl_if_in:nnTF {#1} {back}
    {
      \tikzset{
        tiling/alignment~ set~ location=#1,
        tiling/alignment~ direction={backwards}
      }
    }
    {
      \tikzset{
        tiling/alignment~ location=#1,
        tiling/alignment~ direction={forewards}
      }
    }
    \tl_if_in:nnTF {#2} {using}
    {
      \tikzset{
        tiling/alignment~ set~ edges=#2,
      }
    }
    {
      \tikzset{
        tiling/alignment~ edge=#2,
      }
    }
  },
  tiling/alignment~ set~ location/.code~ args={#1~ back}{
    \tikzset{
      tiling/alignment~ location=#1,
    }
  },
  tiling/alignment~ set~ edges/.code~ args={#1~ using~ #2}{
    \tikzset{
      tiling/alignment~ edge=#1,
      tiling/alignment~ new~ edge=#2
    }
  },
  tiling/alignment~ location/.initial={},
  tiling/alignment~ edge/.initial=a,
  tiling/alignment~ new~ edge/.initial={},
  tiling/alignment~ direction/.initial={forewards},
%    \end{macrocode}
% Default clipping style.
%    \begin{macrocode}
  every~ tile~ clip/.style={clip}
}
%    \end{macrocode}
%
% \begin{function}{\DefineTile}
% This is the user function for defining a tile.
%    \begin{macrocode}
\DeclareDocumentCommand \DefineTile { s m m m }
{
%    \end{macrocode}
% Clear the temporary variable.
%    \begin{macrocode}  
  \tl_clear:N \l_@@_tmpa_tl
%    \end{macrocode}
% The 3rd parameter is a list of coordinates at vertices, iterate through them and add them to the list.
%    \begin{macrocode}
  \int_zero:N \l_@@_tmpa_int
  \fp_zero:N \l_@@_saved_x_fp
  \fp_zero:N \l_@@_saved_y_fp
  \tl_map_inline:nn {#4} {
    \str_set:Nn \l_@@_tmpa_str {##1}
    \str_if_eq:VnTF \l_@@_tmpa_str {+}
    {
      \int_incr:N \l_@@_tmpa_int
    }
    {
      \int_case:nn {\l_@@_tmpa_int}
      {
        {0} {
          \bool_set_false:N \l_@@_relative_bool
          \bool_set_true:N \l_@@_update_saved_bool
        }
        {1} {
          \bool_set_true:N \l_@@_relative_bool
          \bool_set_false:N \l_@@_update_saved_bool
        }
        {2} {
          \bool_set_true:N \l_@@_relative_bool
          \bool_set_true:N \l_@@_update_saved_bool
        }

      }
      \str_if_in:NnTF \l_@@_tmpa_str {:}
      {
        \seq_set_split:NVV \l_@@_tmpa_seq \c_@@_colon_str \l_@@_tmpa_str
        \@@_add_coordinate:Nnn \l_@@_tmpa_tl 
        {
          (\seq_item:Nn \l_@@_tmpa_seq {2}) * cosd (\seq_item:Nn \l_@@_tmpa_seq {1})
        }
        {
          (\seq_item:Nn \l_@@_tmpa_seq {2}) * sind (\seq_item:Nn \l_@@_tmpa_seq {1})
        }
      }
      {
        \seq_set_split:NVV \l_@@_tmpa_seq \c_@@_comma_str \l_@@_tmpa_str
        \@@_add_coordinate:Nnn \l_@@_tmpa_tl 
        {
          (\seq_item:Nn \l_@@_tmpa_seq {1})
        }
        {
          (\seq_item:Nn \l_@@_tmpa_seq {2})
        }
      }
      \int_zero:N \l_@@_tmpa_int
    }
  }
%    \end{macrocode}
% Now we make a list of the edge types (from the 2nd parameter), using a prop to keep track of whether an edge is repeated.
%    \begin{macrocode}
  \prop_clear:N \l_@@_tmpa_prop
  \tl_map_inline:nn {#3} {
    \prop_if_in:NnTF \l_@@_tmpa_prop {##1}
    {
      \prop_put:Nnn \l_@@_tmpa_prop {##1} {1}
    }
    {
      \prop_put:Nnn \l_@@_tmpa_prop {##1} {0}
    }
  }
%    \end{macrocode}
% Having established their multiplicity, we now create the edges with their names, appending numbers to their names if used more than once.
%    \begin{macrocode}
  \tl_clear:N \l_@@_tmpb_tl
  \tl_map_inline:nn {#3}
  {
    \tl_clear:N \l_@@_tmpc_tl
    \tl_put_right:Nn \l_@@_tmpc_tl {##1}
    \int_compare:nF {\prop_item:Nn \l_@@_tmpa_prop {##1} == 0} {
      \tl_put_right:Nx \l_@@_tmpc_tl
      {\prop_item:Nn \l_@@_tmpa_prop {##1}}
      \prop_put:Nnx \l_@@_tmpa_prop {##1}
      {\int_eval:n {\prop_item:Nn \l_@@_tmpa_prop {##1} + 1}}
    }
    \tl_put_right:Nx \l_@@_tmpb_tl {{ \l_@@_tmpc_tl }}
  }
%    \end{macrocode}
% Finally, we can create our tile and add it to the global tile prop.
%    \begin{macrocode}
  \prop_gput:Nnx \g_@@_tiles_prop {#2}
  {{\tl_use:N \l_@@_tmpb_tl} {\tl_use:N \l_@@_tmpa_tl}}
%    \end{macrocode}
% Having created the tile, we make a TikZ pic to place it on the page.
%    \begin{macrocode}
  \tikzset{
    #2/.pic={
      \begin{scope}[
        every~ tile~ scope/.try,
        every~ #2~ scope/.try,
        this~ tile~ scope/.try
      ]
%    \end{macrocode}
% Were we given a tile to align ourselves against?
%    \begin{macrocode}
      \@@_keys_get:Nn \l_@@_tmpa_tl {alignment~ location}
      \tl_if_empty:NF \l_@@_tmpa_tl
      {
%    \end{macrocode}
% Yes, we were.
% So we adjust our position accordingly.
% The first job is to transform so that we're along the edge of the receiving tile.
%    \begin{macrocode}
        \group_begin:
%    \end{macrocode}
% First question is whether the alignment tile exists and has the requested edge exists.
% As \Verb+pic+ sets the node prefix, we have to temporarily suspend that (hence working in a group).
%    \begin{macrocode}
        \tikzset{name~ prefix~ ..}
        \tikz_node_if_defined:nTF
        {\l_@@_tmpa_tl -edge~ \@@_keys_get:n {alignment~ edge}~ start}
        {
%    \end{macrocode}
% We get the locations of the start and end of the receiving tile.
%    \begin{macrocode}
          \tikz_scan_point:n {
            (\l_@@_tmpa_tl -edge~ \@@_keys_get:n {alignment~ edge}~ start)
          }
          \dim_set_eq:Nc \l_@@_xa_dim {pgf@x}
          \dim_set_eq:Nc \l_@@_ya_dim {pgf@y}
          \tikz_scan_point:n {
            (\l_@@_tmpa_tl -edge~ \@@_keys_get:n {alignment~ edge}~ end)
          }
          \dim_set_eq:Nc \l_@@_xb_dim {pgf@x}
          \dim_set_eq:Nc \l_@@_yb_dim {pgf@y}
          \@@_keys_get:Nn \l_@@_tmpb_tl {alignment~ direction}
          \tl_if_eq:NnTF \l_@@_tmpb_tl {forewards}
          {
            \dim_gset_eq:NN \g_@@_xa_dim \l_@@_xa_dim
            \dim_gset_eq:NN \g_@@_ya_dim \l_@@_ya_dim
            \dim_gset_eq:NN \g_@@_xb_dim \l_@@_xb_dim
            \dim_gset_eq:NN \g_@@_yb_dim \l_@@_yb_dim
          }
          {
            \dim_gset_eq:NN \g_@@_xa_dim \l_@@_xb_dim
            \dim_gset_eq:NN \g_@@_ya_dim \l_@@_yb_dim
            \dim_gset_eq:NN \g_@@_xb_dim \l_@@_xa_dim
            \dim_gset_eq:NN \g_@@_yb_dim \l_@@_ya_dim
          }
          \dim_gsub:Nn \g_@@_xb_dim {\g_@@_xa_dim}
          \dim_gsub:Nn \g_@@_yb_dim {\g_@@_ya_dim}
          \dim_gset:Nn \g_@@_xb_dim {\g_@@_xb_dim * \dim_ratio:nn {1pt}{1cm}}
          \dim_gset:Nn \g_@@_yb_dim {\g_@@_yb_dim * \dim_ratio:nn {1pt}{1cm}}
        }
        {
%    \end{macrocode}
% We can't transform as either the tile doesn't exist or it doesn't have the requested edge, so fall back to the origin.
%    \begin{macrocode}
          \dim_gset:Nn \g_@@_xa_dim {0pt}
          \dim_gset:Nn \g_@@_ya_dim {0pt}
          \dim_gset:Nn \g_@@_xb_dim {1pt}
          \dim_gset:Nn \g_@@_yb_dim {0pt}
          \msg_error:nnxx { tilings }{ no edge } { \tl_use:N \l_@@_tmpa_tl }
          {\@@_keys_get:n {alignment~ edge} }
        }
        \group_end:
%    \end{macrocode}
% We store the initial points in \Verb+\pgf@xa+ and \Verb+\pgf@ya+ but we want \Verb+\pgf@xb+ and \Verb+\pgf@yb+ to be a vector along the edge.
%
% We shift to the start of the edge.
%    \begin{macrocode}
        \pgftransformshift{\pgfpoint{\g_@@_xa_dim}{\g_@@_ya_dim}}
%    \end{macrocode}
% And normalise the vector along it.
%    \begin{macrocode}
%        \pgfpointnormalised{\pgfpoint{\g_@@_xb_dim}{\g_@@_yb_dim}}
%        \dim_gset_eq:Nc \g_@@_xb_dim {pgf@x}
%        \dim_gset_eq:Nc \g_@@_yb_dim {pgf@y}
%    \end{macrocode}
% Now rotate so that the \(x\)--axis lies along the edge.
%    \begin{macrocode}
        \pgftransformtriangle
        {\pgfpoint{0pt}{0pt}}
        {\pgfpoint{\g_@@_xb_dim}{\g_@@_yb_dim}}
        {\pgfpoint{-\g_@@_yb_dim}{\g_@@_xb_dim}}
%    \end{macrocode}
% The next job is to shift and rotate the current tile so that the correct edge ends up against the receiving tile.
%    \begin{macrocode}
        \str_set:Nx \l_@@_tmpa_str
        {\@@_keys_get:n {alignment~ edge}}
        \str_set:Nx \l_@@_tmpa_str {\str_head:N \l_@@_tmpa_str}
        \str_put_right:Nx \l_@@_tmpa_str
        {\@@_keys_get:n {alignment~ new~ edge}}
        \str_set:Nx \l_@@_tmpb_str {\str_lowercase:f { \l_@@_tmpa_str}}
        \str_if_eq:NNT \l_@@_tmpa_str \l_@@_tmpb_str
        {
          \str_set:Nx \l_@@_tmpb_str
          {\str_uppercase:f { \l_@@_tmpa_str}}
        }

        \IfBooleanT {#1}
        {
          \bool_set:Nn \l_@@_cw_bool {!\l_@@_cw_bool}
        }
        \bool_if:NT \l_@@_cw_bool
        {
          \pgftransformyscale {-1}
        }
        \@@_transform_side_to_axis:NnV \l_@@_cw_bool {#2} \l_@@_tmpb_str
      }
%    \end{macrocode}
% Now that the transformation is finalised, we can render the tile.
% We clip against the tile path so that the tiles don't ``bleed''.
% If we didn't do this, drawing the tile would result in overlaps which can look a bit ugly.
% On the other hand, tight clipping can lead to ``gaps'' between the tiles so we make this optional by enclosing it in a style.
%
% We start by putting coordinates at each vertex, labelled by which edge they are.
%    \begin{macrocode}
      \@@_coordinates_at_vertices:n {#2}
%    \end{macrocode}
% The first action is to clip against the tile path.
%    \begin{macrocode}      
      \UseTile[
        every~ tile~ clip/.try,
        every~ #2~ clip/.try,
        this~ tile~ clip/.try
      ]{#2}
%    \end{macrocode}
% Any pre-actions?
%    \begin{macrocode}
      \tikzset{
        every~ tile~ before~ path/.try,
        every~ #2~ before~ path/.try,
        this~ tile~ before~ path/.try
      }
%    \end{macrocode}
% Now we render the tile path
%    \begin{macrocode}
      \UseTile[
        every~ tile/.try,
        every~ #2/.try,
        this~ tile/.try,
        pic~ actions
      ]{#2}
%    \end{macrocode}
% After drawing the tile and placing the coordinates, 
%    \begin{macrocode}      
      \tikzset{
        every~ tile~ after~ path/.try,
        every~ #2~ after~ path/.try,
        this~ tile~ after~ path/.try
      }
      \end{scope}
    },
%    \end{macrocode}
% This is a shortcut for installing the \Verb+pic+ type.
%    \begin{macrocode}
    #2/.style={
      every~ tile~ pic/.try,
      pic~ type=#2,
    }
  }
}
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\BakeTile}
% This is the user wrapper around the tile creation macros.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_bake_tile:n #1
{
  \prop_get:NnN \g_@@_tiles_prop {#1} \l_@@_tmpa_tl
  \@@_make_tile:nV {#1} \l_@@_tmpa_tl
}

\NewDocumentCommand \BakeTile {m}
{
  \@@_bake_tile:n {#1}
}
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\UseTile}
% This is the command that actually places a tile on the page.
% The first argument is optional and is for styling.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_use_tile:nn #1#2
{
%    \end{macrocode}
% We need to transform the tile to correspond to the current transformation matrix.
% To ensure that we only transform the current tile, we clone it first.
%    \begin{macrocode}
  \tl_if_exist:cTF {g_@@_tile_#2_tl}
  {
    \tl_set_eq:Nc \l_@@_tmp_tile_path_tl {g_@@_tile_#2_tl}
%    \end{macrocode}
% We get the current transformation to apply to this path.
%    \begin{macrocode}
    \pgfgettransform \l_@@_tmpa_tl
%    \end{macrocode}
% Apply the transformation, protocol the path, and render it.
%    \begin{macrocode}
    \spath_transform:NV \l_@@_tmp_tile_path_tl \l_@@_tmpa_tl
    \spath_tikz_path:nV {#1} \l_@@_tmp_tile_path_tl
  }
  {
    \msg_error:nnn { tilings }{ not baked }{#2}
  }
}

\NewDocumentCommand \UseTile {O{} m} 
{
  \@@_use_tile:nn {#1}{#2}
}
%    \end{macrocode}
% \end{function}
%
% \begin{macro}{save tiling path}
% This is a style for a user to take a path and make it into the path for one of the sides.
% It needs to store both that side and the reverse.
%    \begin{macrocode}
\tikzset{
  save~ tiling~ path/.code={
    \tikz@addmode{
%    \end{macrocode}
% Get the current path.
%    \begin{macrocode}
      \pgfsyssoftpath@getcurrentpath\l_@@_tmpa_tl
%    \end{macrocode}
% Normalise the path and save.
%    \begin{macrocode}
      \@@_normalise_path:N \l_@@_tmpa_tl
      \tl_gclear_new:c {g_@@_side_#1_tl}
      \tl_gset_eq:cN {g_@@_side_#1_tl} \l_@@_tmpa_tl
%    \end{macrocode}
% Now create the reverse path.
% The name is the upper case version.
%    \begin{macrocode}
      \tl_set:Nx \l_@@_tmpb_tl {\str_uppercase:n {#1}}
%    \end{macrocode}
% Reverse the path, and relocate to the interval \([0,1]\).
%    \begin{macrocode}
      \spath_reverse:N \l_@@_tmpa_tl
      \spath_transform:Nnnnnnn \l_@@_tmpa_tl {-1} {0} {0} {-1} {1} {0}
      \tl_gclear_new:c {g_@@_side_ \tl_use:N \l_@@_tmpb_tl _tl}
      \tl_gset_eq:cN {g_@@_side_ \tl_use:N \l_@@_tmpb_tl _tl} \l_@@_tmpa_tl
    }
  },
  clone~ tiling~ side~ path/.style~ 2~ args={
    spath/set~ name=tiling~ side,
    spath/clone~ global={#1}{#2}
  },
  flip~ tile/.code={
    \tl_set:Nn \l_@@_tmpa_tl {#1}
    \tl_set:Nn \l_@@_tmpb_tl {true}
    \bool_set:Nn \l_@@_cw_bool {\tl_if_eq_p:NN \l_@@_tmpa_tl \l_@@_tmpb_tl}
  },
  flip~ tile/.default={true},
  spath/prefix/tiling~side/.style={
    spath/set~ prefix=g_@@_side_,
  },
  spath/suffix/tiling~side/.style={
    spath/set~ suffix=_tl,
  },
  clone~ tile~ path/.style~ 2~ args={
    spath/set~ name=tiling~tile,
    spath/clone~ global={#1}{#2}
  },
  spath/prefix/tiling~tile/.style={
    spath/set~ prefix=g_@@_tile_,
  },
  spath/suffix/tiling~tile/.style={
    spath/set~ suffix=_tl,
  },
  expand~ key/.code={
    \exp_args:NV \pgfkeysalso #1
  }
}
%    \end{macrocode}
% \end{macro}
%
% \subsection{Lindenmayer System}
%
% This is an implementation of the Lindenmayer System description of Penrose and other tilings as a way of generating tilings from a specific starting seed.
%
% The implementation uses \Verb+prop+s to store \emph{rules} and \emph{actions}.
% The rules are used to expand the starting seed to a certain level, after which the actions are carried out.
% The syntax is based on the PGF library, but as we're already using \LaTeX3 it is reimplemented in that.
%
% \begin{macro}[internal]{\@@_make_lms:Nnnn}
% This creates the token list of actions, starting with the seed.
% The arguments are: a token list to store the result in, the name of the system, the number of iterations, and the initial state.
%    \begin{macrocode}
\cs_new_nopar:Npn \@@_make_lms:Nnnn #1#2#3#4
{
  \group_begin:
%    \end{macrocode}
% On the first time round, we start with the given seed.
%    \begin{macrocode}
  \tl_set:Nn \l_@@_tmpb_tl {#4}
%    \end{macrocode}
% We repeat the specified number of times.
%    \begin{macrocode}
  \prg_replicate:nn {#3} {
%    \end{macrocode}
% Duplicate the current state.
%    \begin{macrocode}
    \tl_set_eq:NN \l_@@_tmpa_tl \l_@@_tmpb_tl
%    \end{macrocode}
% Clear the receiving token list.
%    \begin{macrocode}
    \tl_clear:N \l_@@_tmpb_tl
%    \end{macrocode}
% Walk through the current list, appending to the receiving list according to the rules.
%    \begin{macrocode}
    \tl_map_inline:Nn \l_@@_tmpa_tl
    {
%    \end{macrocode}
% If a rule exists, copy that.
%    \begin{macrocode}
      \prop_if_in:cnTF {g_@@_#2_lms_rule_prop} {##1}
      {
        \tl_put_right:Nx \l_@@_tmpb_tl
        {\prop_item:cn {g_@@_#2_lms_rule_prop} {##1} }
      }
      {
%    \end{macrocode}
% Otherwise, just copy the token.
%    \begin{macrocode}
        \tl_put_right:Nn \l_@@_tmpb_tl {##1}
      }
    }
  }
%    \end{macrocode}
% We've done all this inside a group, now pass the result outside.
%    \begin{macrocode}
  \tl_set:Nn \l_@@_tmpa_tl {
    \group_end:
    \tl_set:Nn #1
  }
  \tl_put_right:Nx \l_@@_tmpa_tl {{\tl_use:N \l_@@_tmpb_tl}}
  \tl_use:N \l_@@_tmpa_tl
}
\cs_generate_variant:Nn \@@_make_lms:Nnnn {Nnnx}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\@@_invoke_lms:Nn}
% This carries out the actions specified by the resulting rules.
%    \begin{macrocode}
\cs_new_nopar:Npn \@@_invoke_lms:Nn #1#2
{
  \group_begin:
%    \end{macrocode}
% Walk through the given list, carrying out the corresponding action if it exists.
% If not, look at the default.
% Otherwise, just do nothing.
%    \begin{macrocode}
  \tl_map_inline:Nn #1 {
    \prop_if_in:cnTF {g_@@_#2_lms_action_prop} {##1}
    {
      \prop_item:cn {g_@@_#2_lms_action_prop} {##1}
    }
    {
      \prop_if_in:cnT {g_@@_default_lms_action_prop} {##1}
      {
        \prop_item:cn {g_@@_default_lms_action_prop} {##1}
      }
    }
  }
  \group_end:
}
%    \end{macrocode}
% \end{macro}
%
% We keep track of the number of tiles.
%    \begin{macrocode}
\int_new:N \g_@@_tile_int
\int_new:N \g_@@_tiles_int
%    \end{macrocode}
%
% \begin{function}{\TilingDecomposition}
% This is the user macro to invoke the decomposition.
% The arguments are: optional styles, the name, number of iterations, and starting seed.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_tiling_decomposition:nnnn #1#2#3#4
{
  \group_begin:
  \tikzset{#1}
  \@@_make_lms:Nnnx \l_@@_tmpa_tl {#2} {#3} {#4}
  \@@_count_lms:N \l_@@_tmpa_tl
  \int_gzero:N \g_@@_tile_int
  \int_set:Nn \l_@@_pentagon_parity_int {2}
  \@@_invoke_lms:Nn \l_@@_tmpa_tl {#2}
  \group_end:
}

\NewDocumentCommand \TilingDecomposition { O{} m m m }
{
 \@@_tiling_decomposition:nnnn {#1}{#2}{#3}{#4}
}
%    \end{macrocode}
% \end{function}
%
% \begin{macro}[internal]{\@@_count_lms:N}
% This counts the number of tiles in the string.
%    \begin{macrocode}
\cs_new_nopar:Npn \@@_count_lms:N #1
{
  \int_gzero:N \g_@@_tiles_int
  \tl_map_inline:Nn #1
  {
    \tl_if_eq:nnT {##1} {T}
    {
      \int_gincr:N \g_@@_tiles_int
    }
    \tl_if_eq:nnT {##1} {t}
    {
      \int_gincr:N \g_@@_tiles_int
    }
    \tl_if_eq:nnT {##1} {G}
    {
      \int_gincr:N \g_@@_tiles_int
    }
    \tl_if_eq:nnT {##1} {g}
    {
      \int_gincr:N \g_@@_tiles_int
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
% This is a \Verb+\tikzset+ mechanism for setting the dimensions of the tiling.
%    \begin{macrocode}
\tikzset{
  tiling~ step/.code={
    \dim_set:Nn \l_@@_step_dim {#1}
  }
}
%    \end{macrocode}
%
%    \begin{macrocode}
\ExplSyntaxOff
%    \end{macrocode}
%
% \iffalse
%</tilings>
% \fi
%
%
% \iffalse
%<*penrose>
% \fi
%
%    \begin{macrocode}
\RequirePackage{tikz}
\usetikzlibrary{tilings}
\ProvidesFile {tikzlibrarytilings.penrose.code.tex} [2023/03/22 v1.6 TikZ pics for Penrose tiles]
%    \end{macrocode}
%
%
% Create the pre-defined tile shapes.
%
% \begin{itemize}
% \item Thin Rhombus.
%    \begin{macrocode}
\DefineTile{thin rhombus}{a A B b}
{
 {0 , 0}
 {cosd(18) , sind(18)}
 {2*cosd(18) , 0}
 {cosd(18) , -sind(18)}
}
%    \end{macrocode}
%
% \item Thick Rhombus.
%    \begin{macrocode}
\DefineTile{thick rhombus}{B a A b}
{
 {0 , 0}
 {cosd(36) , sind(36)}
 {2*cosd(36) , 0}
 {cosd(36) , -sind(36)}
}
%    \end{macrocode}
%
% \item Dart.
%    \begin{macrocode}
\DefineTile{dart}{c a A C}
{
 {0 , 0}
 {2*sind(18)*cosd(108) , 2*sind(18)*sind(108)}
 {2*sind(18) , 0}
 {2*sind(18)*cosd(108) , -2*sind(18)*sind(108)}
}
%    \end{macrocode}
%
% \item Kite.
%    \begin{macrocode}
\DefineTile{kite}{a c C A}
{
 {0 , 0}
 {cosd(36) , sind(36)}
 {1 , 0}
 {cosd(36) , -sind(36)}
}
%    \end{macrocode}
%
% \item Golden Triangle.
%    \begin{macrocode}
\DefineTile{golden triangle}{a c b}
{
 {0 , 0}
 {cosd(18) , sind(18)}
 {cosd(18) , -sind(18)}
}
%    \end{macrocode}
%
% \item Reverse Golden Triangle.
%    \begin{macrocode}
\DefineTile {reverse golden triangle}{B C A}
{
 {0 , 0}
 {cosd(18) , sind(18)}
 {cosd(18) , -sind(18)}
}
%    \end{macrocode}
%
% \item Golden Gnomon
%    \begin{macrocode}
\DefineTile {golden gnomon}{C b A}
{
 {0 , 0}
 {cosd(36) , sind(36)}
 {2*cosd(36) , 0}
}
%    \end{macrocode}
%
% \item Reverse Golden Gnomon
%    \begin{macrocode}
\DefineTile {reverse golden gnomon}{a B c}
{
 {0 , 0}
 {2*cosd(36) , 0}
 {cosd(36) , -sind(36)}
}
%    \end{macrocode}
%
% \item Primary Pentagon (pentagon 5)
%    \begin{macrocode}
\DefineTile {pentagon 5}{a a a a a}
{
 {0 , 0}
 {cosd(108) , sind(108)}
 {1+cosd(72)+cosd(144) , sind(72)+sind(144)}
 {1+cosd(72) , sind(72)}
 {1 , 0}
}
%    \end{macrocode}
%
% \item Secondary Pentagon (pentagon 3)
%    \begin{macrocode}
\DefineTile {pentagon 3}{A b a a b}
{
 {0 , 0}
 {cosd(108) , sind(108)}
 {1+cosd(72)+cosd(144) , sind(72)+sind(144)}
 {1+cosd(72) , sind(72)}
 {1 , 0}
}
%    \end{macrocode}
%
% \item Tertiary Pentagon (pentagon 2)
%    \begin{macrocode}
\DefineTile {pentagon 2}{d A e c A}
{
 {0 , 0}
 {cosd(108) , sind(108)}
 {1+cosd(72)+cosd(144) , sind(72)+sind(144)}
 {1+cosd(72) , sind(72)}
 {1 , 0}
}
%    \end{macrocode}
%
% \item Pentagram
%    \begin{macrocode}
\DefineTile {pentagram}{C E C E C E C E C E}
{
  {1 , 0}
  {1-cosd(36) , -sind(36)}
  {1-cosd(36)-cosd(108) , -sind(36)-sind(108)}
  {cosd(108) , -sind(108)}
  {-1+3*cosd(108)+cosd(36) , -sind(36)-sind(108)}
  {-1+2*cosd(108)+cosd(36) , -sind(36)}
  {-1+2*cosd(108) , 0}
  {2*cosd(108) , 0}
  {cosd(108) , sind(108)}
  {0 , 0}
}
%    \end{macrocode}
%
% \item Boat
%    \begin{macrocode}
\DefineTile {boat}{C E C E B D B}
{
 {-1+2*cosd(108) , 0}
 {2*cosd(108) , 0}
 {cosd(108) , sind(108)}
 {0 , 0}
 {1 , 0}
 {1-cosd(36) , -sind(36)}
 {-1+2*cosd(108)+cosd(36) , -sind(36)}
}
%    \end{macrocode}
%
% \item Diamond.
%    \begin{macrocode}
\DefineTile {diamond}{D B B D}
{
 {0 , 0}
 {cosd(18) , sind(18)}
 {2*cosd(18) , 0}
 {cosd(18) , -sind(18)}
}
%    \end{macrocode}
% \end{itemize}
%
%
% Place the arcs
%    \begin{macrocode}
\tikzset{
  every thin rhombus before path/.code={
    \path[every circle arc/.try] (-edge a end) circle[radius=1/4];
    \path[every long arc/.try] (-edge b start) circle[radius=1/4];
  },
  every thick rhombus before path/.code={
    \path[every circle arc/.try] (-edge a end) circle[radius=1/4];
    \path[every long arc/.try] (-edge B start) circle[radius=3/4];
  },
  every kite before path/.code={
    \path[every circle arc/.try] (-edge a start) circle[radius=2/(sqrt(5)+1)];
    \path[every long arc/.try] (-edge c end) circle[radius=2/(3+sqrt(5))];
  },
  every dart before path/.code={
    \path[every circle arc/.try] (-edge a end) circle[radius=1 - 2/(sqrt(5)+1)];
    \path[every long arc/.try] (-edge c start) circle[radius=2/(sqrt(5)+1) - 2/(3+sqrt(5))];
  }
}
%    \end{macrocode}
%
% Now bake the tiles.
%
%    \begin{macrocode}
\BakeTile {thin rhombus}
\BakeTile {thick rhombus} 
\BakeTile {dart}
\BakeTile {kite}
\BakeTile {golden triangle}
\BakeTile {reverse golden triangle}
\BakeTile {golden gnomon}
\BakeTile {reverse golden gnomon}
\BakeTile {pentagon 5}
\BakeTile {pentagon 3}
\BakeTile {pentagon 2}
\BakeTile {pentagram}
\BakeTile {boat}
\BakeTile {diamond}
%    \end{macrocode}
%
%
% \subsection{Lindenmayer System}
%
%    \begin{macrocode}
\ExplSyntaxOn
%    \end{macrocode}
%
% These are the rules for generating rhombus tilings with the Lindenmayer System procedure.
%
%    \begin{macrocode}
\prop_new:N \g_@@_rhombus_lms_rule_prop
\prop_gput:Nnn \g_@@_rhombus_lms_rule_prop {T} {[f*sT][f>g]}
\prop_gput:Nnn \g_@@_rhombus_lms_rule_prop {t} {[f_st][f>G]}
\prop_gput:Nnn \g_@@_rhombus_lms_rule_prop {G} {[f+sG][sf>g][sf*sT]}
\prop_gput:Nnn \g_@@_rhombus_lms_rule_prop {g} {[f-sg][sf>G][sf_st]}
%    \end{macrocode}
%
% These are the rules for generating kite and dart tilings.
%    \begin{macrocode}
\prop_new:N \g_@@_kite_lms_rule_prop
\prop_gput:Nnn \g_@@_kite_lms_rule_prop {T} {[f*sT][f>st][+sg]}
\prop_gput:Nnn \g_@@_kite_lms_rule_prop {t} {[f_st][f>sT][-sG]}
\prop_gput:Nnn \g_@@_kite_lms_rule_prop {G} {[f*+sG][sT]}
\prop_gput:Nnn \g_@@_kite_lms_rule_prop {g} {[f-_sg][st]}
%    \end{macrocode}
%
% These are the rules for generating pentagon tilings.
%    \begin{macrocode}
\prop_new:N \g_@@_pentagon_lms_rule_prop
\prop_gput:Nnn \g_@@_pentagon_lms_rule_prop {P}
{[s>P][1sF+Q][1+sF+Q][1*sF+Q][1-sF+Q][1_sF+Q]} % pentagon 5
\prop_gput:Nnn \g_@@_pentagon_lms_rule_prop {Q}
{[s>P][1+sFR][1*sF*R][1-sF+Q][1_sF+Q][1sF+Q][->fsD]} % pentagon 3
\prop_gput:Nnn \g_@@_pentagon_lms_rule_prop {R}
{[s>P][1-sF+Q][1+sF*R][1*sFR][1_sF*R][1sFR][_>fsD][>fsD]} % pentagon 2
\prop_gput:Nnn \g_@@_pentagon_lms_rule_prop {G}
{
  [s>G]
  [se[>d+R][e1B]]
  [+se[>d+R][e1B]]
  [-se[>d+R][e1B]]
  [*se[>d+R][e1B]]
  [_se[>d+R][e1B]]
} % pentagram
\prop_gput:Nnn \g_@@_pentagon_lms_rule_prop {B}
{
  [s>G]
  [se[>d+R][e1B]]
  [+se[>d+R][e1B]]
  [-se[>d+R][e1B]]
} % boat
\prop_gput:Nnn \g_@@_pentagon_lms_rule_prop {D}
{[s>d+R][s>eG][se1B]} % diamond
%    \end{macrocode}
%
% Each of the standard tilings can also be drawn using triangles using the same rules.
%    \begin{macrocode}
\prop_gset_eq:NN \g_@@_rtriangle_lms_rule_prop
\g_@@_rhombus_lms_rule_prop
\prop_gset_eq:NN \g_@@_ktriangle_lms_rule_prop
\g_@@_kite_lms_rule_prop
%    \end{macrocode}
%
% These hold the various actions.
%    \begin{macrocode}
\prop_new:N \g_@@_default_lms_action_prop
\prop_new:N \g_@@_rhombus_lms_action_prop
\prop_new:N \g_@@_kite_lms_action_prop
\prop_new:N \g_@@_rtriangle_lms_action_prop
\prop_new:N \g_@@_ktriangle_lms_action_prop
\prop_new:N \g_@@_pentagon_lms_action_prop
%    \end{macrocode}
%
% We need some parameters.
%    \begin{macrocode}
\dim_new:N \l_@@_step_dim
\dim_set:Nn \l_@@_step_dim {1cm}
%    \end{macrocode}
%
% These are the defaults, which will be used in all the rule sets.
%    \begin{macrocode}
\prop_gput:Nnn \g_@@_default_lms_action_prop {[} {\group_begin:}
\prop_gput:Nnn \g_@@_default_lms_action_prop {]} {\group_end:}
\prop_gput:Nnn \g_@@_default_lms_action_prop {f}
{\pgftransformxshift{\l_@@_step_dim}}
\prop_gput:Nnn \g_@@_default_lms_action_prop {s} {
  \fp_set:Nn \l_@@_tmpa_fp { 2 * sind(18) * \l_@@_step_dim }
  \dim_set:Nn \l_@@_step_dim {\fp_to_dim:N \l_@@_tmpa_fp}
}
%    \end{macrocode}
%
% The rhombus rules need a variety of turns.
%    \begin{macrocode}
\prop_gput:Nnn \g_@@_rhombus_lms_action_prop {+}
{\pgftransformrotate{144}}
\prop_gput:Nnn \g_@@_rhombus_lms_action_prop {*}
{\pgftransformrotate{108}}
\prop_gput:Nnn \g_@@_rhombus_lms_action_prop {-}
{\pgftransformrotate{216}}
\prop_gput:Nnn \g_@@_rhombus_lms_action_prop {_}
{\pgftransformrotate{252}}
\prop_gput:Nnn \g_@@_rhombus_lms_action_prop {>}
{\pgftransformrotate{180}}
%    \end{macrocode}
%
% Up to now, the actions for the rhombus and its triangle replacement are the same.
%    \begin{macrocode}
\prop_gset_eq:NN \g_@@_rtriangle_lms_action_prop
\g_@@_rhombus_lms_action_prop
%    \end{macrocode}
%
% Now we do the actions that actually draw something.
%    \begin{macrocode}
\prop_gput:Nnn \g_@@_rhombus_lms_action_prop {T} {
  \group_begin:
%    \end{macrocode}
% As we go through, we keep track of how many tiles we've drawn.
%    \begin{macrocode}
  \int_gincr:N \g_@@_tile_int
%    \end{macrocode}
% Set up the position, size, and angle correctly.
%    \begin{macrocode}
  \pgftransformrotate{198}
  \fp_set:Nn \l_@@_tmpa_fp {\l_@@_step_dim*2*cosd(18)}
  \pgftransformxshift{-\fp_to_dim:N \l_@@_tmpa_fp}
  \fp_set:Nn \l_@@_tmpa_fp {\l_@@_step_dim/(1cm)}
  \pgftransformscale{\fp_use:N \l_@@_tmpa_fp}
%    \end{macrocode}
% Now we draw the thin rhombus, applying every style we can possibly imagine.
% The \Verb+tile+ style gets the current tile and total tile numbers passed to it.
%    \begin{macrocode}
  \tl_set:Nx \l_@@_tmpc_tl
  {
    {\int_use:N  \g_@@_tile_int}
    {\int_use:N \g_@@_tiles_int}
  }
  \UseTile[
    every~ tile/.try,
    every~ thin~ rhombus/.try,
    tile~ \int_use:N \g_@@_tile_int/.try,
    tile/.try/.expand~ once=\l_@@_tmpc_tl
  ]{thin~rhombus}
  \group_end:
}
%    \end{macrocode}
%
% Same for the thick rhombus.
%    \begin{macrocode}
\prop_gput:Nnn \g_@@_rhombus_lms_action_prop {G} {
  \group_begin:
  \int_gincr:N \g_@@_tile_int
  \fp_set:Nn \l_@@_tmpa_fp {\l_@@_step_dim/(1cm)/(2*cosd(36))}
  \pgftransformscale{\fp_use:N \l_@@_tmpa_fp}
  \tl_set:Nx \l_@@_tmpc_tl
  {
    {\int_use:N  \g_@@_tile_int}
    {\int_use:N \g_@@_tiles_int}
  }
  \UseTile[
    every~ tile/.try,
    every~ thick~ rhombus/.try,
    tile~ \int_use:N \g_@@_tile_int/.try,
    tile/.try/.expand~ once=\l_@@_tmpc_tl
  ]{thick~rhombus}
  \group_end:
}
%    \end{macrocode}
%
% Now we do the same for the kite and dart tiling.
%    \begin{macrocode}
\prop_gput:Nnn \g_@@_kite_lms_action_prop {+} {\pgftransformrotate{36}}
\prop_gput:Nnn \g_@@_kite_lms_action_prop {*} {\pgftransformrotate{108}}
\prop_gput:Nnn \g_@@_kite_lms_action_prop {-} {\pgftransformrotate{-36}}
\prop_gput:Nnn \g_@@_kite_lms_action_prop {_}
{\pgftransformrotate{-108}}
\prop_gput:Nnn \g_@@_kite_lms_action_prop {>} {\pgftransformrotate{180}}
%    \end{macrocode}
%
%    \begin{macrocode}
\prop_gset_eq:NN \g_@@_ktriangle_lms_action_prop
\g_@@_kite_lms_action_prop
%    \end{macrocode}
%
%    \begin{macrocode}
\prop_gput:Nnn \g_@@_kite_lms_action_prop {T} {
  \group_begin:
  \int_gincr:N \g_@@_tile_int
  \pgftransformrotate{36}
  \fp_set:Nn \l_@@_tmpa_fp {\l_@@_step_dim/(1cm)}
  \pgftransformscale{\fp_use:N \l_@@_tmpa_fp}
  \tl_set:Nx \l_@@_tmpc_tl
  {
    {\int_use:N  \g_@@_tile_int}
    {\int_use:N \g_@@_tiles_int}
  }
  \UseTile[
    every~ tile/.try,
    every~ kite/.try,
    tile~ \int_use:N \g_@@_tile_int/.try,
    tile/.try/.expand~ once=\l_@@_tmpc_tl
  ]{kite}
  \group_end:
}
%    \end{macrocode}
%
%    \begin{macrocode}
\prop_gput:Nnn \g_@@_kite_lms_action_prop {g} {
  \group_begin:
  \int_gincr:N \g_@@_tile_int
  \pgftransformrotate{144}
  \pgftransformxshift{-\l_@@_step_dim * 2 * sin(18)}
  \fp_set:Nn \l_@@_tmpa_fp {\l_@@_step_dim/(1cm)}
  \pgftransformscale{\fp_use:N \l_@@_tmpa_fp}
  \tl_set:Nx \l_@@_tmpc_tl
  {
    {\int_use:N  \g_@@_tile_int}
    {\int_use:N \g_@@_tiles_int}
  }
  \UseTile[
    every~ tile/.try,
    every~ dart/.try,
    tile~ \int_use:N \g_@@_tile_int/.try,
    tile/.try/.expand~ once=\l_@@_tmpc_tl
  ]{dart}
  \group_end:
}
%    \end{macrocode}
%
% Now we set up the actions for the triangle variations.
%    \begin{macrocode}
\prop_gput:Nnn \g_@@_rtriangle_lms_action_prop {T} {
  \group_begin:
  \int_gincr:N \g_@@_tile_int
  \pgftransformrotate{18}
  \fp_set:Nn \l_@@_tmpa_fp {\l_@@_step_dim/(1cm)}
  \pgftransformscale{\fp_use:N \l_@@_tmpa_fp}
  \tl_set:Nx \l_@@_tmpc_tl
  {
    {\int_use:N  \g_@@_tile_int}
    {\int_use:N \g_@@_tiles_int}
  }
  \UseTile[
    every~ tile/.try,
    every~ reverse~ golden~ triangle/.try,
    tile~ \int_use:N \g_@@_tile_int/.try,
    tile/.try/.expand~ once=\l_@@_tmpc_tl
  ]{reverse~ golden~ triangle}
  \group_end:
}
%    \end{macrocode}
%
%    \begin{macrocode}
\prop_gput:Nnn \g_@@_rtriangle_lms_action_prop {t} {
  \group_begin:
  \int_gincr:N \g_@@_tile_int
  \pgftransformrotate{-18}
  \fp_set:Nn \l_@@_tmpa_fp {\l_@@_step_dim/(1cm)}
  \pgftransformscale{\fp_use:N \l_@@_tmpa_fp}
  \tl_set:Nx \l_@@_tmpc_tl
  {
    {\int_use:N  \g_@@_tile_int}
    {\int_use:N \g_@@_tiles_int}
  }
  \tl_set:Nx \l_@@_tmpc_tl
  {
    {\int_use:N  \g_@@_tile_int}
    {\int_use:N \g_@@_tiles_int}
  }
  \UseTile[
    every~ tile/.try,
    every~ golden~ triangle/.try,
    tile~ \int_use:N \g_@@_tile_int/.try,
    tile/.try/.expand~ once=\l_@@_tmpc_tl
  ]{golden~ triangle}
  \group_end:
}
%    \end{macrocode}
%
%    \begin{macrocode}
\prop_gput:Nnn \g_@@_rtriangle_lms_action_prop {G} {
  \group_begin:
  \int_gincr:N \g_@@_tile_int
  \pgftransformrotate{180}
  \pgftransformxshift{-\l_@@_step_dim}
  \fp_set:Nn \l_@@_tmpa_fp {\l_@@_step_dim/(1cm)/(2*cosd(36))}
  \pgftransformscale{\fp_use:N \l_@@_tmpa_fp}
  \tl_set:Nx \l_@@_tmpc_tl
  {
    {\int_use:N  \g_@@_tile_int}
    {\int_use:N \g_@@_tiles_int}
  }
  \UseTile[
    every~ tile/.try,
    every~ reverse~ golden~ gnomon/.try,
    tile~ \int_use:N \g_@@_tile_int/.try,
    tile/.try/.expand~ once=\l_@@_tmpc_tl
  ]{reverse~ golden~ gnomon}
  \group_end:
}
%    \end{macrocode}
%
%    \begin{macrocode}
\prop_gput:Nnn \g_@@_rtriangle_lms_action_prop {g} {
  \group_begin:
  \int_gincr:N \g_@@_tile_int
  \pgftransformrotate{180}
  \pgftransformxshift{-\l_@@_step_dim}
  \fp_set:Nn \l_@@_tmpa_fp {\l_@@_step_dim/(1cm)/(2*cosd(36))}
  \pgftransformscale{\fp_use:N \l_@@_tmpa_fp}
  \tl_set:Nx \l_@@_tmpc_tl
  {
    {\int_use:N  \g_@@_tile_int}
    {\int_use:N \g_@@_tiles_int}
  }
  \UseTile[
    every~ tile/.try,
    every~ golden~ gnomon/.try,
    tile~ \int_use:N \g_@@_tile_int/.try,
    tile/.try/.expand~ once=\l_@@_tmpc_tl
  ]{golden~ gnomon}
  \group_end:
}
%    \end{macrocode}
%
%    \begin{macrocode}
\prop_gput:Nnn \g_@@_ktriangle_lms_action_prop {T} {
  \group_begin:
  \int_gincr:N \g_@@_tile_int
  \pgftransformrotate{18}
  \fp_set:Nn \l_@@_tmpa_fp {\l_@@_step_dim/(1cm)}
  \pgftransformscale{\fp_use:N \l_@@_tmpa_fp}
  \tl_set:Nx \l_@@_tmpc_tl
  {
    {\int_use:N  \g_@@_tile_int}
    {\int_use:N \g_@@_tiles_int}
  }
  \UseTile[
    every~ tile/.try,
    every~ reverse~ golden~ triangle/.try,
    tile~ \int_use:N \g_@@_tile_int/.try,
    tile/.try/.expand~ once=\l_@@_tmpc_tl
  ]{reverse~ golden~ triangle}
  \group_end:
}
%    \end{macrocode}
%
%    \begin{macrocode}
\prop_gput:Nnn \g_@@_ktriangle_lms_action_prop {t} {
  \group_begin:
  \int_gincr:N \g_@@_tile_int
  \pgftransformrotate{-18}
  \fp_set:Nn \l_@@_tmpa_fp {\l_@@_step_dim/(1cm)}
  \pgftransformscale{\fp_use:N \l_@@_tmpa_fp}
  \tl_set:Nx \l_@@_tmpc_tl
  {
    {\int_use:N  \g_@@_tile_int}
    {\int_use:N \g_@@_tiles_int}
  }
  \UseTile[
    every~ tile/.try,
    every~ golden~ triangle/.try,
    tile~ \int_use:N \g_@@_tile_int/.try,
    tile/.try/.expand~ once=\l_@@_tmpc_tl
  ]{golden~ triangle}
  \group_end:
}
%    \end{macrocode}
%
%    \begin{macrocode}
\prop_gput:Nnn \g_@@_ktriangle_lms_action_prop {G} {
  \group_begin:
  \int_gincr:N \g_@@_tile_int
  \pgftransformrotate{180}
  \pgftransformxshift{-\l_@@_step_dim}
  \fp_set:Nn \l_@@_tmpa_fp {\l_@@_step_dim/(1cm)/(2*cosd(36))}
  \pgftransformscale{\fp_use:N \l_@@_tmpa_fp}
  \tl_set:Nx \l_@@_tmpc_tl
  {
    {\int_use:N  \g_@@_tile_int}
    {\int_use:N \g_@@_tiles_int}
  }
  \UseTile[
    every~ tile/.try,
    every~ reverse~ golden~ gnomon/.try,
    tile~ \int_use:N \g_@@_tile_int/.try,
    tile/.try/.expand~ once=\l_@@_tmpc_tl
  ]{reverse~ golden~ gnomon}
  \group_end:
}
%    \end{macrocode}
%
%    \begin{macrocode}
\prop_gput:Nnn \g_@@_ktriangle_lms_action_prop {g} {
  \group_begin:
  \int_gincr:N \g_@@_tile_int
  \pgftransformrotate{180}
  \pgftransformxshift{-\l_@@_step_dim}
  \fp_set:Nn \l_@@_tmpa_fp {\l_@@_step_dim/(1cm)/(2*cosd(36))}
  \pgftransformscale{\fp_use:N \l_@@_tmpa_fp}
  \tl_set:Nx \l_@@_tmpc_tl
  {
    {\int_use:N  \g_@@_tile_int}
    {\int_use:N \g_@@_tiles_int}
  }
  \UseTile[
    every~ tile/.try,
    every~ golden~ gnomon/.try,
    tile~ \int_use:N \g_@@_tile_int/.try,
    tile/.try/.expand~ once=\l_@@_tmpc_tl
  ]{golden~ gnomon}
  \group_end:
}
%    \end{macrocode}
%
% Now we do the same for the pentagonal tilings.
%
% The rules need a variety of turns.
%    \begin{macrocode}
\int_new:N \l_@@_pentagon_parity_int
\seq_new:N \l_@@_pentagon_parity_seq
\seq_set_from_clist:Nn \l_@@_pentagon_parity_seq {odd,even}
\prop_gput:Nnn \g_@@_pentagon_lms_action_prop {1} {
  \int_set:Nn \l_@@_pentagon_parity_int
  {3 -  \l_@@_pentagon_parity_int}
  }
\prop_gput:Nnn \g_@@_pentagon_lms_action_prop {+}
{\pgftransformrotate{72}}
\prop_gput:Nnn \g_@@_pentagon_lms_action_prop {*}
{\pgftransformrotate{144}}
\prop_gput:Nnn \g_@@_pentagon_lms_action_prop {-}
{\pgftransformrotate{288}}
\prop_gput:Nnn \g_@@_pentagon_lms_action_prop {_}
{\pgftransformrotate{216}}
\prop_gput:Nnn \g_@@_pentagon_lms_action_prop {>}
{\pgftransformrotate{180}}
\prop_gput:Nnn \g_@@_pentagon_lms_action_prop {|}
{\pgftransformxscale{-1}}
%    \end{macrocode}
% The scale factor is different.
%    \begin{macrocode}
\prop_gput:Nnn \g_@@_pentagon_lms_action_prop {s} {
  \fp_set:Nn \l_@@_tmpa_fp
  {
    1/(2 + 2 * cosd(72) ) * \l_@@_step_dim
  }
  \dim_set:Nn \l_@@_step_dim {\fp_to_dim:N \l_@@_tmpa_fp}
}
%    \end{macrocode}
% And we tend to work better vertically.
%    \begin{macrocode}
\prop_gput:Nnn \g_@@_pentagon_lms_action_prop {f} {
  \fp_set:Nn \l_@@_tmpa_fp {  tand(54)/2 * \l_@@_step_dim }
  \pgftransformyshift{\fp_to_dim:N \l_@@_tmpa_fp}
}
\prop_gput:Nnn \g_@@_pentagon_lms_action_prop {F} {
  \fp_set:Nn \l_@@_tmpa_fp {  tand(54) * \l_@@_step_dim }
  \pgftransformyshift{\fp_to_dim:N \l_@@_tmpa_fp}
}
\prop_gput:Nnn \g_@@_pentagon_lms_action_prop {d} {
  \fp_set:Nn \l_@@_tmpa_fp
  {
    (tand(54)/2 - tand(72)/2 + sind(36) ) * \l_@@_step_dim
  }
  \pgftransformyshift{\fp_to_dim:N \l_@@_tmpa_fp}
}
\prop_gput:Nnn \g_@@_pentagon_lms_action_prop {e} {
  \fp_set:Nn \l_@@_tmpa_fp
  {
    tand(54) * cosd(36) * \l_@@_step_dim
  }
  \pgftransformyshift{\fp_to_dim:N \l_@@_tmpa_fp}
}
%    \end{macrocode}
%
%    \begin{macrocode}
\prop_gput:Nnn \g_@@_pentagon_lms_action_prop {P} {
  \group_begin:
  \int_gincr:N \g_@@_tile_int
  \fp_set:Nn \l_@@_tmpa_fp {\l_@@_step_dim/2}
  \pgftransformxshift{-\fp_to_dim:N \l_@@_tmpa_fp}
  \fp_set:Nn \l_@@_tmpa_fp {\l_@@_step_dim*tand(54)/2}
  \pgftransformyshift{-\fp_to_dim:N \l_@@_tmpa_fp}
  \fp_set:Nn \l_@@_tmpa_fp {\l_@@_step_dim/(1cm)}
  \pgftransformscale{\fp_use:N \l_@@_tmpa_fp}
  \tl_set:Nx \l_@@_tmpc_tl
  {
    {\int_use:N  \g_@@_tile_int}
    {\int_use:N \g_@@_tiles_int}
  }
  \UseTile[
    every~ tile/.try,
    every~ pentagon/.try,
    every~
    \seq_item:Nn \l_@@_pentagon_parity_seq
    {\l_@@_pentagon_parity_int}
    \space pentagon/.try,
    every~ pentagon~ 5/.try,
    tile~ \int_use:N \g_@@_tile_int/.try,
    tile/.try/.expand~ once=\l_@@_tmpc_tl
  ]{pentagon~5}
  \group_end:
}
%    \end{macrocode}
%
%    \begin{macrocode}
\prop_gput:Nnn \g_@@_pentagon_lms_action_prop {Q} {
  \group_begin:
  \int_gincr:N \g_@@_tile_int
  \fp_set:Nn \l_@@_tmpa_fp {\l_@@_step_dim/2}
  \pgftransformxshift{-\fp_to_dim:N \l_@@_tmpa_fp}
  \fp_set:Nn \l_@@_tmpa_fp {\l_@@_step_dim*tand(54)/2}
  \pgftransformyshift{-\fp_to_dim:N \l_@@_tmpa_fp}
  \fp_set:Nn \l_@@_tmpa_fp {\l_@@_step_dim/(1cm)}
  \pgftransformscale{\fp_use:N \l_@@_tmpa_fp}
  \tl_set:Nx \l_@@_tmpc_tl
  {
    {\int_use:N  \g_@@_tile_int}
    {\int_use:N \g_@@_tiles_int}
  }
  \UseTile[
    every~ tile/.try,
    every~ pentagon/.try,
    every~
    \seq_item:Nn \l_@@_pentagon_parity_seq
    {\l_@@_pentagon_parity_int}
    \space pentagon/.try,
    every~ pentagon~ 3/.try,
    tile~ \int_use:N \g_@@_tile_int/.try,
    tile/.try/.expand~ once=\l_@@_tmpc_tl
  ]{pentagon~3}
  \group_end:
}
%    \end{macrocode}
%
%    \begin{macrocode}
\prop_gput:Nnn \g_@@_pentagon_lms_action_prop {R} {
  \group_begin:
  \int_gincr:N \g_@@_tile_int
  \fp_set:Nn \l_@@_tmpa_fp {\l_@@_step_dim/2}
  \pgftransformxshift{-\fp_to_dim:N \l_@@_tmpa_fp}
  \fp_set:Nn \l_@@_tmpa_fp {\l_@@_step_dim*tand(54)/2}
  \pgftransformyshift{-\fp_to_dim:N \l_@@_tmpa_fp}
  \fp_set:Nn \l_@@_tmpa_fp {\l_@@_step_dim/(1cm)}
  \pgftransformscale{\fp_use:N \l_@@_tmpa_fp}
  \tl_set:Nx \l_@@_tmpc_tl
  {
    {\int_use:N  \g_@@_tile_int}
    {\int_use:N \g_@@_tiles_int}
  }
  \UseTile[
    every~ tile/.try,
    every~ pentagon/.try,
    every~
    \seq_item:Nn \l_@@_pentagon_parity_seq
    {\l_@@_pentagon_parity_int}
    \space pentagon/.try,
    every~ pentagon~ 2/.try,
    tile~ \int_use:N \g_@@_tile_int/.try,
    tile/.try/.expand~ once=\l_@@_tmpc_tl
  ]{pentagon~2}
  \group_end:
}
%    \end{macrocode}
%
%    \begin{macrocode}
\prop_gput:Nnn \g_@@_pentagon_lms_action_prop {G} {
  \group_begin:
  \int_gincr:N \g_@@_tile_int
%  \pgftransformrotate{198}
  \fp_set:Nn \l_@@_tmpa_fp {\l_@@_step_dim*cosd(72)}
  \pgftransformxshift{\fp_to_dim:N \l_@@_tmpa_fp}
  \fp_set:Nn \l_@@_tmpa_fp {\l_@@_step_dim*tand(54)*cosd(72)}
  \pgftransformyshift{\fp_to_dim:N \l_@@_tmpa_fp}
  \fp_set:Nn \l_@@_tmpa_fp {\l_@@_step_dim/(1cm)}
  \pgftransformscale{\fp_use:N \l_@@_tmpa_fp}
  \tl_set:Nx \l_@@_tmpc_tl
  {
    {\int_use:N  \g_@@_tile_int}
    {\int_use:N \g_@@_tiles_int}
  }
  \UseTile[
    every~ tile/.try,
    every~ pentagram/.try,
    tile~ \int_use:N \g_@@_tile_int/.try,
    tile/.try/.expand~ once=\l_@@_tmpc_tl
  ]{pentagram}
  \group_end:
}
%    \end{macrocode}
%
%    \begin{macrocode}
\prop_gput:Nnn \g_@@_pentagon_lms_action_prop {B} {
  \group_begin:
  \int_gincr:N \g_@@_tile_int
%  \pgftransformrotate{198}
  \fp_set:Nn \l_@@_tmpa_fp {\l_@@_step_dim*cosd(72)}
  \pgftransformxshift{\fp_to_dim:N \l_@@_tmpa_fp}
  \fp_set:Nn \l_@@_tmpa_fp {\l_@@_step_dim*tand(54)*cosd(72)}
  \pgftransformyshift{\fp_to_dim:N \l_@@_tmpa_fp}
  \fp_set:Nn \l_@@_tmpa_fp {\l_@@_step_dim/(1cm)}
  \pgftransformscale{\fp_use:N \l_@@_tmpa_fp}
  \tl_set:Nx \l_@@_tmpc_tl
  {
    {\int_use:N  \g_@@_tile_int}
    {\int_use:N \g_@@_tiles_int}
  }
  \UseTile[
    every~ tile/.try,
    every~ boat/.try,
    tile~ \int_use:N \g_@@_tile_int/.try,
    tile/.try/.expand~ once=\l_@@_tmpc_tl
  ]{boat}
  \group_end:
}
%    \end{macrocode}
%
%    \begin{macrocode}
\prop_gput:Nnn \g_@@_pentagon_lms_action_prop {D} {
  \group_begin:
  \int_gincr:N \g_@@_tile_int
  \pgftransformrotate{90}
  \fp_set:Nn \l_@@_tmpa_fp {\l_@@_step_dim*cosd(18)}
  \pgftransformxshift{-\fp_to_dim:N \l_@@_tmpa_fp}
  \fp_set:Nn \l_@@_tmpa_fp {\l_@@_step_dim/(1cm)}
  \pgftransformscale{\fp_use:N \l_@@_tmpa_fp}
  \tl_set:Nx \l_@@_tmpc_tl
  {
    {\int_use:N  \g_@@_tile_int}
    {\int_use:N \g_@@_tiles_int}
  }
  \UseTile[
    every~ tile/.try,
    every~ diamond/.try,
    tile~ \int_use:N \g_@@_tile_int/.try,
    tile/.try/.expand~ once=\l_@@_tmpc_tl
  ]{diamond}
  \group_end:
}
%    \end{macrocode}
%
%    \begin{macrocode}
\ExplSyntaxOff
%    \end{macrocode}
%
% \iffalse
%</penrose>
% \fi
%
% \iffalse
%<*polykite>
% \fi
%
%    \begin{macrocode}
\RequirePackage{tikz}
\usetikzlibrary{tilings}
\ProvidesFile {tikzlibrarytilings.polykite.code.tex} [2023/03/22 v1.6 TikZ pics for Aperiodical Polykite tiles]
%    \end{macrocode}
%
% \begin{function}{\DefinePolykiteTile}
% Define one of the family of polykite tiles.
% Needs a name and length parameters.
%    \begin{macrocode}
\DeclareDocumentCommand \DefinePolykiteTile {m m m}
{
  \DefineTile {#1} {1 1 2 2 1 1 2 2 2 2 1 1 2 2}
  {
    {0 : #3}
    ++{90 : #2}
    ++{150 : #2}
    ++{240 : #3}
    ++{180 : #3}
    ++{-90 : #2}
    ++{210 : #2}
    ++{-60 : #3}
    ++{0 : #3}
    ++{0 : #3}
    ++{60 : #3}
    ++{-30 : #2}
    ++{30 : #2}
    ++{120 : #3}
  }
}
%    \end{macrocode}
% \end{function}
%
% \begin{itemize}
% \item Aperiodical Hat.
%    \begin{macrocode}
\DefinePolykiteTile{aperiodical hat}{sqrt(3)/2}{1/2}
%    \end{macrocode}
% \item Aperiodical Turtle.
%    \begin{macrocode}
\DefinePolykiteTile{aperiodical turtle}{1/2}{sqrt(3)/2}
%    \end{macrocode}
%
% \item Meta Clusters
%
% The mapping between the notation in the \href{preprint}{https://arxiv.org/abs/2303.10798} is:
%
% \begin{align*}
% A^+, A^- &\mapsto a, A \\
% B^+, B^- &\mapsto b, B\\
% F^+, F^- &\mapsto c, C\\
% X^+, X^- &\mapsto d, D\\
% L &\mapsto 1
% \end{align*}
%
%    \begin{macrocode}
\DefineTile{meta cluster T}{A A b}
{
{ -1.5 , -sqrt(3)/2 }
{  1.5 , -sqrt(3)/2 }
{  0   ,  sqrt(3) }  
}
\DefineTile{meta cluster P}{A 1 D d b 1 D d}
{
{ -1.5 , -sqrt(3)/2 }
{  1.5 , -sqrt(3)/2 }
{  1 , 0 }
{ .5 , sqrt(3)/2 }
{ -.5 , sqrt(3)/2 }
{ -3.5, sqrt(3)/2 }
{ -3, 0 }
{ -2.5, -sqrt(3)/2 }
}
\DefineTile{meta cluster F}{1 D c C d b 1 D d}
{
{ -1.5 , -sqrt(3)/2 }
{ -.5 , -sqrt(3)/2 }
{  .5 , -sqrt(3)/2 }
{  1 , 0 }
{ .5 , sqrt(3)/2 }
{ -.5 , sqrt(3)/2 }
{ -3.5, sqrt(3)/2 }
{ -3, 0 }
{ -2.5, -sqrt(3)/2 }
}
\DefineTile{meta cluster H}{a D d B D d B D d}
{
{ -.5 , 3*sqrt(3)/2 }
{ -2, 0 }
{ -2.5, -sqrt(3)/2 }
{ -2, -sqrt(3) }
{ 1, -sqrt(3) }
{ 2, -sqrt(3) }
{ 2.5, -sqrt(3)/2 }
{ 1, sqrt(3)}
{ .5 , 3*sqrt(3)/2 }
}
%    \end{macrocode}
% \item Super Clusters
%
%    \begin{macrocode}
\DefineTile{super cluster T}{A A b}
{
{ -30 : 3 * (1 + sqrt(5))/2 / sqrt(3) }
{ 90 : 3 * (1 + sqrt(5))/2 / sqrt(3) }
{ 210 : 3 * (1 + sqrt(5))/2 / sqrt(3) }
}
% 1 + 3phi, 1 + 2phi
\DefineTile{super cluster P}{A 1 D d b 1 D d}
{
{ 1, 0 }
++{ 3*(1 + sqrt(5))/2, 0 }
++{ 120 : 1 + sqrt(5) }
++{ 120 : 1 }
++{ -1, 0 }
++{ -3*(1 + sqrt(5))/2, 0 }
++{ -60 : 1 + sqrt(5) }
++{ -60 : 1}
}
\DefineTile{super cluster F}{1 D c C d b 1 D d}
{
{ 1, 0 }
++{ 1 + sqrt(5), 0 }
++{ 1, 0 }
+{ -.75 + (2 + sqrt(5)) * sqrt(3)/4 * sqrt(3)/3, (2 + sqrt(5)) * sqrt(3)/4 + 3/4 * sqrt(3)/3 }
++{ -1.5, (2 + sqrt(5)) * sqrt(3)/2 }
++{ -1, 0 }
++{ -3*(1 + sqrt(5))/2, 0 }
++{ -60 : 1 + sqrt(5) }
++{ -60 : 1}
}
\DefineTile{super cluster H}{d B D d B D d a D}
{
{.5, (.5 + (1 + sqrt(5))/2) * sqrt(3)}
++{-1,0}
++{240 : 3*(1+sqrt(5))/2}
++{240 : 1}
++{300 : 1}
++{ 3*(1+sqrt(5))/2, 0 }
++{1, 0}
++{60 : 1}
++{120 : 3*(1+sqrt(5))/2 }
}
%    \end{macrocode}
% \item Subclusters
%
%    \begin{macrocode}
\DefineTile{subcluster H}{b b A}
{
  { 0, 0 }
  { 3, 0 }
  { 60 : 3 }
}
\DefineTile{subcluster T}{a a B}
{
  { 0, 0 }
  { 3, 0 }
  { 60 : 3 }
}
\DefineTile{subcluster P}{ 1 a 1 B }
{
  { 0, 0 }
  { 1, 0 }
  { 4, 0 }
  { 3, 0 }
}
\DefineTile{subcluster F}{ 1 1 F f B }
{
  { 0, 0 }
  { 1, 0 }
  +{ 60 : 1 }
  { 2, 0 }
  { 3, 0 }
}
%    \end{macrocode}
% \end{itemize}
%
% The P and F subclusters have no area, so clipping against them is not helpful.
%    \begin{macrocode}
\tikzset{
  no clip/.code={%
    \tikz@addmode{\tikz@mode@clipfalse}%
  },
  every subcluster P clip/.style={no clip},
  every subcluster F clip/.style={no clip},
}
%    \end{macrocode}
%
%
%    \begin{macrocode}
\BakeTile {aperiodical hat}
\BakeTile {aperiodical turtle}
\BakeTile {meta cluster T}
\BakeTile {meta cluster P}
\BakeTile {meta cluster F}
\BakeTile {meta cluster H}
\BakeTile {super cluster T}
\BakeTile {super cluster P}
\BakeTile {super cluster F}
\BakeTile {super cluster H}
%    \end{macrocode}
%
% The subclusters are deformed by default.
%
%    \begin{macrocode}
\ExplSyntaxOn
\clist_map_inline:nn {a,A,b,B,f,F}
{
  \tl_new:c {g_@@_side_polykite_#1_tl}
  \tl_if_exist:cF {g_@@_side_#1_tl}
  {
    \tl_new:c {g_@@_side_#1_tl}
  }
}

\tl_gset:cn {g_@@_side_polykite_a_tl}
{%
  \pgfsyssoftpath@movetotoken {0pt}{-0.3333332942822268pt}%
  \pgfsyssoftpath@linetotoken {0.0833331478405773pt}{-0.1889954840909892pt}%
  \pgfsyssoftpath@linetotoken {0.3333332942822268pt}{-0.3333332942822268pt}%
  \pgfsyssoftpath@linetotoken {0.5833333235705567pt}{-0.1889954840909892pt}%
  \pgfsyssoftpath@linetotoken {0.6666667057177732pt}{-0.3333332942822268pt}%
  \pgfsyssoftpath@linetotoken {1pt}{-0.3333332942822268pt}%
}
\tl_gset:cn {g_@@_side_polykite_A_tl}
{%
  \pgfsyssoftpath@movetotoken {0pt}{0.33333pt}%
  \pgfsyssoftpath@linetotoken {0.33333pt}{0.33333pt}%
  \pgfsyssoftpath@linetotoken {0.41667pt}{0.189pt}%
  \pgfsyssoftpath@linetotoken {0.66667pt}{0.33333pt}%
  \pgfsyssoftpath@linetotoken {0.91667pt}{0.189pt}%
  \pgfsyssoftpath@linetotoken {1pt}{0.33333pt}%
}
\tl_gset:cn {g_@@_side_polykite_b_tl}
{%
  \pgfsyssoftpath@movetotoken {0pt}{0pt}%
  \pgfsyssoftpath@linetotoken {0.3333332942822268pt}{0pt}%
  \pgfsyssoftpath@linetotoken {0.4166665592761237pt}{0.1443378101912376pt}%
  \pgfsyssoftpath@linetotoken {0.6666667057177732pt}{0pt}%
  \pgfsyssoftpath@linetotoken {0.9166666178527835pt}{0.1443378101912376pt}%
  \pgfsyssoftpath@linetotoken {1pt}{0pt}%
}
\tl_gset:cn {g_@@_side_polykite_B_tl}
{%
  \pgfsyssoftpath@movetotoken {0pt}{0pt}%
  \pgfsyssoftpath@linetotoken {0.08333pt}{-0.14433pt}%
  \pgfsyssoftpath@linetotoken {0.33333pt}{0pt}%
  \pgfsyssoftpath@linetotoken {0.58333pt}{-0.14433pt}%
  \pgfsyssoftpath@linetotoken {0.66667pt}{0pt}%
  \pgfsyssoftpath@linetotoken {1pt}{0pt}%
}
\tl_gset:cn {g_@@_side_polykite_f_tl}
{%
  \pgfsyssoftpath@movetotoken {0pt}{-2.00000070292pt}%
  \pgfsyssoftpath@linetotoken {0.74999982427pt}{-1.566987221617321pt}%
  \pgfsyssoftpath@linetotoken {1pt}{-2.00000070292pt}%
}
\tl_gset:cn {g_@@_side_polykite_F_tl}
{%
  \pgfsyssoftpath@movetotoken {0pt}{2pt}%
  \pgfsyssoftpath@linetotoken {0.25pt}{1.56699pt}%
  \pgfsyssoftpath@linetotoken {1pt}{2pt}%
}

\clist_map_inline:nn {a,A,b,B,f,F}
{
  \tl_gclear_new:c {g_@@_side_backup_#1_tl}
  \tl_gset_eq:cc {g_@@_side_backup_#1_tl} {g_@@_side_#1_tl}
  \tl_gclear_new:c {g_@@_side_#1_tl}
  \tl_gset_eq:cc {g_@@_side_#1_tl}{g_@@_side_polykite_#1_tl}
}
\ExplSyntaxOff

\BakeTile{subcluster H}
\BakeTile{subcluster T}
\BakeTile{subcluster P}
\BakeTile{subcluster F}

\ExplSyntaxOn
\clist_map_inline:nn {a,A,b,B,f,F}
{
  \tl_gset_eq:cc {g_@@_side_#1_tl} {g_@@_side_backup_#1_tl}
}
\ExplSyntaxOff
%    \end{macrocode}
%
% \iffalse
%</polykite>
% \fi
%
% \iffalse
%<*penrosedep>
% \fi
%
%    \begin{macrocode}
\ProvidesFile {tikzlibrarypenrose.code.tex} [2023/03/22 v1.6 TikZ pics for Penrose tiles]
\usetikzlibrary{tilings.penrose}
%    \end{macrocode}
%
% Backwards compatibility mode:
%
% \begin{itemize}
% \item \Verb+\SetPenrosePath+ is \Verb+\SetTilingPath+
% \item \Verb+\BakePenrosePath+ and \Verb+\MakePenrosePath+ are \Verb+\BakeTilingPath+
% \item \Verb+\UsePenroseTile+ is \Verb+\UseTile+
% \item \Verb+\PenroseDecomposition+ is \Verb+\TilingDecomposition+
% \end{itemize}
%    \begin{macrocode}
\ExplSyntaxOn
\NewDocumentCommand \SetPenrosePath { m }
{
  \@@_set_tiling_path:n {#1}
}
\NewDocumentCommand \BakePenroseTile {m}
{
  \@@_bake_tile:n {#1}
}
\NewDocumentCommand \MakePenroseTile {m}
{
  \@@_bake_tile:n {#1}
}
\NewDocumentCommand \UsePenroseTile {O{} m} 
{
  \@@_use_tile:nn {#1}{#2}
}
\NewDocumentCommand \PenroseDecomposition { O{} m m m }
{
 \@@_tiling_decomposition:nnnn {#1}{#2}{#3}{#4}
}
\ExplSyntaxOff
%    \end{macrocode}
%
%    \begin{macrocode}
\tikzset{
  save Penrose path/.forward to=/tikz/save tiling path,
  clone Penrose side path/.forward to=/tikz/clone tiling side path,
  spath/prefix/Penrose side/.forward to=/tikz/spath/prefix/tiling side,
  spath/suffix/Penrose side/.forward to=/tikz/spath/suffix/tiling side,
  clone Penrose tile path/.forward to=/tikz/clone tiling tile path,
  spath/prefix/Penrose tile/.forward to=/tikz/spath/prefix/tiling tile,
  spath/suffix/Penrose tile/.forward to=/tikz/spath/suffix/tiling tile,
  Penrose step/.forward to=/tikz/tiling step,
  every tile/.append style={
    every Penrose tile/.try
  },
  every tile clip/.append style={
    every Penrose tile clip/.try
  },
  every tile pic/.append style={
    every Penrose pic/.try
  },
  tile/.append style={
    Penrose tile #1/.try,
    Penrose tile/.try=#1
  }
}
%    \end{macrocode}
%
% \iffalse
%</penrosedep>
% \fi
%
% \end{implementation}
%\Finale
\endinput
